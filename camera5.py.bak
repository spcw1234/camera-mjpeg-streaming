import cv2
import gi
import os
import serial
import threading
import sys
import termios
import tty
import time
import select
import numpy as np
import json
import uuid
import traceback
import paho.mqtt.client as mqtt
import hashlib
import subprocess
import time
from rknnlite.api import RKNNLite as RKNN
import psutil
import gc

# pynputÏùÄ GUI ÌôòÍ≤ΩÏóêÏÑúÎßå ÏÇ¨Ïö© Í∞ÄÎä•ÌïòÎØÄÎ°ú Ï°∞Í±¥Î∂Ä import
try:
    from pynput import keyboard
    PYNPUT_AVAILABLE = True
except ImportError:
    print("‚ö†Ô∏è  pynputÏùÑ ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§ (headless ÌôòÍ≤Ω). ÌÇ§Î≥¥Îìú Ï†úÏñ¥Îäî ÎπÑÌôúÏÑ±ÌôîÎê©ÎãàÎã§.")
    PYNPUT_AVAILABLE = False

gi.require_version('Gst', '1.0')
gi.require_version('GstRtspServer', '1.0')
from gi.repository import Gst, GstRtspServer, GLib

# Import DeepSORT dependencies
from deep_sort import nn_matching
from deep_sort.detection import Detection
from deep_sort.tracker import Tracker
from deep_sort.tools import generate_detections as gdet

def test_camera_device(device_path):
    """Test if a camera device is working"""
    try:
        cap = cv2.VideoCapture(device_path)
        if not cap.isOpened():
            return False
        ret, frame = cap.read()
        cap.release()
        return ret and frame is not None
    except:
        return False

class MQTTClient:
    def __init__(self, broker_host='localhost', broker_port=1883, topic_prefix='camera', gst_server=None):
        """MQTT ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¥àÍ∏∞Ìôî"""
        self.broker_host = broker_host
        self.broker_port = broker_port
        self.topic_prefix = topic_prefix
        self.unique_id = self._generate_fixed_device_id()  # Í≥†Ï†ïÎêú ÎîîÎ∞îÏù¥Ïä§ ID ÏÉùÏÑ±
        self.client = mqtt.Client()
        self.gst_server = gst_server  # GStreamer ÏÑúÎ≤Ñ Ï∞∏Ï°∞
        
        # MQTT Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨ ÏÑ§Ï†ï
        self.client.on_connect = self.on_connect
        self.client.on_disconnect = self.on_disconnect
        self.client.on_publish = self.on_publish
        self.client.on_message = self.on_message
        
        self.connected = False
        
        # Ïπ¥Î©îÎùº Ïù¥Îèô ÏΩúÎ∞± Ìï®Ïàò (Ïô∏Î∂ÄÏóêÏÑú ÏÑ§Ï†ï)
        self.move_callback = None
        
        print(f"MQTT ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¥àÍ∏∞Ìôî - Unique ID: {self.unique_id}")
    
    def on_connect(self, client, userdata, flags, rc):
        """MQTT Î∏åÎ°úÏª§ Ïó∞Í≤∞ ÏΩúÎ∞±"""
        print(f"MQTT Ïó∞Í≤∞ ÏΩúÎ∞± Ìò∏Ï∂úÎê® - ÏΩîÎìú: {rc}")
        if rc == 0:
            self.connected = True
            print(f"‚úì MQTT Î∏åÎ°úÏª§Ïóê Ïó∞Í≤∞Îê® ({self.broker_host}:{self.broker_port})")
            print(f"‚úì Í≥†Ï†ï ÎîîÎ∞îÏù¥Ïä§ ID: {self.unique_id}")
            
            # Ïπ¥Î©îÎùº Ïù¥Îèô Î™ÖÎ†π Íµ¨ÎèÖ
            move_topic = f"{self.unique_id}/move"
            result = self.client.subscribe(move_topic)
            print(f"‚úì Ïπ¥Î©îÎùº Ïù¥Îèô Î™ÖÎ†π Íµ¨ÎèÖ: {move_topic} (Í≤∞Í≥º: {result})")
            
            # Ïó∞Í≤∞ Ïãú GStreamer Ï†ïÎ≥¥ Ï†ÑÏÜ°
            print("Ï¥àÍ∏∞ Î©îÏãúÏßÄ Ï†ÑÏÜ° Ï§ë...")
            self.send_gst_info()
            # ÏÉÅÌÉú Ï†ÑÏÜ°
            self.send_status("start")  # ÏãúÏûë ÏãúÏóêÎäî "start" ÏÉÅÌÉú
        else:
            print(f"‚úó MQTT Ïó∞Í≤∞ Ïã§Ìå® - ÏΩîÎìú: {rc}")
            if rc == 1:
                print("  - ÏûòÎ™ªÎêú ÌîÑÎ°úÌÜ†ÏΩú Î≤ÑÏ†Ñ")
            elif rc == 2:
                print("  - ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ID Í±∞Î∂ÄÎê®")
            elif rc == 3:
                print("  - ÏÑúÎ≤Ñ ÏÇ¨Ïö© Î∂àÍ∞Ä")
            elif rc == 4:
                print("  - ÏûòÎ™ªÎêú ÏÇ¨Ïö©ÏûêÎ™Ö ÎòêÎäî ÎπÑÎ∞ÄÎ≤àÌò∏")
            elif rc == 5:
                print("  - Ïù∏Ï¶ùÎêòÏßÄ ÏïäÏùå")
            else:
                print(f"  - Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò: {rc}")
    
    def on_disconnect(self, client, userdata, rc):
        """MQTT Î∏åÎ°úÏª§ Ïó∞Í≤∞ Ìï¥Ï†ú ÏΩúÎ∞±"""
        self.connected = False
        print("MQTT Î∏åÎ°úÏª§ Ïó∞Í≤∞ Ìï¥Ï†úÎê®")
    
    def on_publish(self, client, userdata, mid):
        """Î©îÏãúÏßÄ Î∞úÌñâ ÏôÑÎ£å ÏΩúÎ∞±"""
        print(f"MQTT Î©îÏãúÏßÄ Î∞úÌñâ ÏôÑÎ£å - MID: {mid}")
    
    def on_message(self, client, userdata, msg):
        """MQTT Î©îÏãúÏßÄ ÏàòÏã† ÏΩúÎ∞±"""
        try:
            topic = msg.topic
            payload = msg.payload.decode('utf-8')
            
            print(f"MQTT Î©îÏãúÏßÄ ÏàòÏã† - Topic: {topic}, Payload: {payload}")
            
            # Ïπ¥Î©îÎùº Ïù¥Îèô Î™ÖÎ†π Ï≤òÎ¶¨
            if topic.endswith('/move') and self.move_callback:
                # JSON ÌòïÌÉúÏùò Î™ÖÎ†π ÌååÏã± ÏãúÎèÑ
                try:
                    import json
                    command_data = json.loads(payload)
                    if isinstance(command_data, dict) and 'move' in command_data:
                        move_command = command_data['move']
                        print(f"JSON Î™ÖÎ†π ÌååÏã±: {move_command}")
                        self.move_callback(move_command)
                    else:
                        # ÏùºÎ∞ò Î¨∏ÏûêÏó¥ Î™ÖÎ†π Ï≤òÎ¶¨
                        self.move_callback(payload)
                except json.JSONDecodeError:
                    # JSONÏù¥ ÏïÑÎãå Í≤ΩÏö∞ ÏùºÎ∞ò Î¨∏ÏûêÏó¥Î°ú Ï≤òÎ¶¨
                    print(f"ÏùºÎ∞ò Î¨∏ÏûêÏó¥ Î™ÖÎ†π: {payload}")
                    self.move_callback(payload)
                
        except Exception as e:
            print(f"Î©îÏãúÏßÄ Ï≤òÎ¶¨ Ïò§Î•ò: {e}")
            traceback.print_exc()
    
    def set_move_callback(self, callback):
        """Ïπ¥Î©îÎùº Ïù¥Îèô ÏΩúÎ∞± Ìï®Ïàò ÏÑ§Ï†ï"""
        self.move_callback = callback
    
    def connect(self):
        """MQTT Î∏åÎ°úÏª§Ïóê Ïó∞Í≤∞"""
        try:
            print(f"MQTT Î∏åÎ°úÏª§ Ïó∞Í≤∞ ÏãúÎèÑ: {self.broker_host}:{self.broker_port}")
            self.client.connect(self.broker_host, self.broker_port, 60)
            self.client.loop_start()
            
            # Ïó∞Í≤∞Ïù¥ ÏôÑÎ£åÎê† ÎïåÍπåÏßÄ ÎåÄÍ∏∞ (ÏµúÎåÄ 10Ï¥à)
            connect_timeout = 10
            for i in range(connect_timeout):
                if self.connected:
                    print("MQTT Ïó∞Í≤∞ ÏÑ±Í≥µ!")
                    # ÌïòÌä∏ÎπÑÌä∏ Ïä§Î†àÎìú ÏãúÏûë
                    self.start_heartbeat()
                    return True
                time.sleep(1)
                print(f"MQTT Ïó∞Í≤∞ ÎåÄÍ∏∞ Ï§ë... ({i+1}/{connect_timeout})")
            
            print("MQTT Ïó∞Í≤∞ ÌÉÄÏûÑÏïÑÏõÉ")
            return False
        except Exception as e:
            print(f"MQTT Ïó∞Í≤∞ Ïã§Ìå®: {e}")
            return False
    
    def start_heartbeat(self):
        """ÌïòÌä∏ÎπÑÌä∏, ÏÉÅÌÉú, GStreamer Ï†ïÎ≥¥ Ï†ÑÏÜ° Ïä§Î†àÎìú ÏãúÏûë"""
        def heartbeat_thread():
            sta_counter = 0  # ÏÉÅÌÉú Ï†ÑÏÜ° Ïπ¥Ïö¥ÌÑ∞
            gst_counter = 0  # GStreamer Ï†ïÎ≥¥ Ï†ÑÏÜ° Ïπ¥Ïö¥ÌÑ∞
            print("ÌïòÌä∏ÎπÑÌä∏ Ïä§Î†àÎìú ÏãúÏûë - Ï≤´ Î≤àÏß∏ Ï†ÑÏÜ° ÎåÄÍ∏∞ Ï§ë...")
            
            while True:  # self.connected ÎåÄÏã† Î¨¥Ìïú Î£®ÌîÑ ÏÇ¨Ïö©
                try:
                    # Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏
                    if not self.connected:
                        print("MQTT Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥Ïßê - ÌïòÌä∏ÎπÑÌä∏ ÎåÄÍ∏∞ Ï§ë...")
                        time.sleep(5)
                        continue
                    
                    # ÌïòÌä∏ÎπÑÌä∏ "a" Ï†ÑÏÜ° (5Ï¥àÎßàÎã§)
                    print(f"ÌïòÌä∏ÎπÑÌä∏ Ï†ÑÏÜ° ÏãúÎèÑ... (Ïó∞Í≤∞ÏÉÅÌÉú: {self.connected})")
                    self.send_heartbeat()
                    
                    # ÏÉÅÌÉú "on" Ï†ÑÏÜ° (5Î∂ÑÎßàÎã§ = 60Î≤àÏùò ÌïòÌä∏ÎπÑÌä∏ÎßàÎã§)
                    if sta_counter >= 60:
                        print("ÏÉÅÌÉú Ï†ÑÏÜ° ÏãúÎèÑ...")
                        self.send_status("on")
                        sta_counter = 0
                    else:
                        sta_counter += 1
                    
                    # GStreamer Ï†ïÎ≥¥ Ï†ÑÏÜ° (10Ï¥àÎßàÎã§ = 2Î≤àÏùò ÌïòÌä∏ÎπÑÌä∏ÎßàÎã§)
                    if gst_counter >= 2:
                        print("GStreamer Ï†ïÎ≥¥ Ï†ÑÏÜ° ÏãúÎèÑ...")
                        self.send_gst_info()
                        gst_counter = 0
                    else:
                        gst_counter += 1
                    
                    print(f"Îã§Ïùå ÌïòÌä∏ÎπÑÌä∏ÍπåÏßÄ 5Ï¥à ÎåÄÍ∏∞... (ÏÉÅÌÉú: {sta_counter}/60, GST: {gst_counter}/2)")
                    time.sleep(5)  # 5Ï¥àÎßàÎã§ ÌïòÌä∏ÎπÑÌä∏ Ï†ÑÏÜ°
                    
                except Exception as e:
                    print(f"ÌïòÌä∏ÎπÑÌä∏/ÏÉÅÌÉú/GStreamer Ï†ÑÏÜ° Ïã§Ìå®: {e}")
                    traceback.print_exc()
                    time.sleep(5)
            
        heartbeat_t = threading.Thread(target=heartbeat_thread, daemon=True)
        heartbeat_t.start()
        print("ÌïòÌä∏ÎπÑÌä∏ Î∞è ÏÉÅÌÉú Ï†ÑÏÜ° Ïä§Î†àÎìú ÏãúÏûëÎê®")
    
    def disconnect(self):
        """MQTT Î∏åÎ°úÏª§ Ïó∞Í≤∞ Ìï¥Ï†ú"""
        if self.connected:
            self.client.loop_stop()
            self.client.disconnect()
    
    def send_gst_info(self):
        """GStreamer Ï†ïÎ≥¥Î•º Í∞ÑÎã®ÌïòÍ≤å Ï†ÑÏÜ° - URLÎßå"""
        rtsp_url = "rtsp://spcwtech.mooo.com:7200/test"
        if self.gst_server:
            rtsp_url = self.gst_server.get_rtsp_url()
        
        # URLÎßå Ï†ÑÏÜ° (uniqueIDÎäî ÌÜ†ÌîΩÏóê Ïù¥ÎØ∏ Ìè¨Ìï®ÎêòÏñ¥ ÏûàÏùå)
        message = rtsp_url
        
        topic = f"{self.unique_id}/CV/gst"
        
        if self.connected:
            result = self.client.publish(topic, message)
            if result.rc == mqtt.MQTT_ERR_SUCCESS:
                print(f"GStreamer Ï†ïÎ≥¥ Ï†ÑÏÜ° - Topic: {topic}")
            else:
                print(f"Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïã§Ìå® - ÏΩîÎìú: {result.rc}")
    
    def send_heartbeat(self):
        """ÌïòÌä∏ÎπÑÌä∏ Ï†ÑÏÜ° - uniqueID/CV/sta"""
        topic = f"{self.unique_id}/CV/sta"
        message = "a"  # ÌïòÌä∏ÎπÑÌä∏ ÏÉÅÌÉú
        
        if self.connected:
            result = self.client.publish(topic, message)
            if result.rc == mqtt.MQTT_ERR_SUCCESS:
                print(f"ÌïòÌä∏ÎπÑÌä∏ Ï†ÑÏÜ° - Topic: {topic}, Message: {message}")
            else:
                print(f"ÌïòÌä∏ÎπÑÌä∏ Ï†ÑÏÜ° Ïã§Ìå® - ÏΩîÎìú: {result.rc}")
        else:
            print("MQTT Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏùå - ÌïòÌä∏ÎπÑÌä∏ Ï†ÑÏÜ° Ïã§Ìå®")
    
    def send_status(self, status):
        """ÏÉÅÌÉú Ï†ÑÏÜ° - uniqueID/CV/sta"""
        topic = f"{self.unique_id}/CV/sta"
        
        if self.connected:
            result = self.client.publish(topic, status)
            if result.rc == mqtt.MQTT_ERR_SUCCESS:
                print(f"ÏÉÅÌÉú Ï†ÑÏÜ° - Topic: {topic}, Status: {status}")
            else:
                print(f"ÏÉÅÌÉú Ï†ÑÏÜ° Ïã§Ìå® - ÏΩîÎìú: {result.rc}")
        else:
            print("MQTT Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏùå - ÏÉÅÌÉú Ï†ÑÏÜ° Ïã§Ìå®")
    
    def send_detection_data(self, detections_info):
        """Í∞êÏßÄÎêú Í∞ùÏ≤¥ Ï†ïÎ≥¥ Ï†ÑÏÜ° - uniqueID/CV/obj"""
        topic = f"{self.unique_id}/CV/obj"
        
        if self.connected and detections_info:
            message = json.dumps(detections_info)
            result = self.client.publish(topic, message)
            if result.rc == mqtt.MQTT_ERR_SUCCESS:
                print(f"Í∞ùÏ≤¥ Í∞êÏßÄ Ï†ïÎ≥¥ Ï†ÑÏÜ° - Topic: {topic}, Objects: {len(detections_info)}")
            else:
                print(f"Í∞ùÏ≤¥ Í∞êÏßÄ Ï†ïÎ≥¥ Ï†ÑÏÜ° Ïã§Ìå® - ÏΩîÎìú: {result.rc}")
        else:
            if not self.connected:
                print("MQTT Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏùå - Í∞ùÏ≤¥ Í∞êÏßÄ Ï†ïÎ≥¥ Ï†ÑÏÜ° Ïã§Ìå®")

    def _generate_fixed_device_id(self):
        """MAC Ï£ºÏÜåÏôÄ ÏãúÏä§ÌÖú Ï†ïÎ≥¥Î•º Í∏∞Î∞òÏúºÎ°ú Í≥†Ï†ïÎêú ÎîîÎ∞îÏù¥Ïä§ ID ÏÉùÏÑ±"""
        try:
            # MAC Ï£ºÏÜå Í∞ÄÏ†∏Ïò§Í∏∞
            import subprocess
            result = subprocess.run(['cat', '/sys/class/net/eth0/address'], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                mac_address = result.stdout.strip()
            else:
                # eth0Í∞Ä ÏóÜÏúºÎ©¥ Îã§Î•∏ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ ÏãúÎèÑ
                result = subprocess.run(['ls', '/sys/class/net/'], 
                                      capture_output=True, text=True)
                interfaces = result.stdout.strip().split('\n')
                mac_address = "unknown"
                for interface in interfaces:
                    if interface not in ['lo']:  # loopback Ï†úÏô∏
                        try:
                            result = subprocess.run(['cat', f'/sys/class/net/{interface}/address'], 
                                                  capture_output=True, text=True)
                            if result.returncode == 0:
                                mac_address = result.stdout.strip()
                                break
                        except:
                            continue
            
            # ÏãúÏä§ÌÖú Ï†ïÎ≥¥ Ï∂îÍ∞Ä (Îçî Í≥†Ïú†ÌïòÍ≤å ÎßåÎì§Í∏∞ ÏúÑÌï¥)
            hostname_result = subprocess.run(['hostname'], capture_output=True, text=True)
            hostname = hostname_result.stdout.strip() if hostname_result.returncode == 0 else "unknown"
            
            # MAC Ï£ºÏÜåÏôÄ Ìò∏Ïä§Ìä∏Î™ÖÏùÑ Ï°∞Ìï©ÌïòÏó¨ Ìï¥Ïãú ÏÉùÏÑ±
            unique_string = f"{mac_address}-{hostname}-camera5"
            device_id = hashlib.md5(unique_string.encode()).hexdigest()[:8]
            
            return f"CAM_{device_id}"
            
        except Exception as e:
            print(f"Í≥†Ï†ï ID ÏÉùÏÑ± Ïã§Ìå®, Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©: {e}")
            # Ïã§Ìå® Ïãú Í∏∞Î≥∏Í∞í Î∞òÌôò
            return "CAM_DEFAULT"

class GStreamerRTSPServer:
    def __init__(self, port=7200, mount_point="/test"):
        """GStreamer RTSP ÏÑúÎ≤Ñ Ï¥àÍ∏∞Ìôî"""
        self.port = port
        self.mount_point = mount_point
        self.server = None
        self.factory = None
        self.mainloop = None
        self.running = False
        self.appsrc = None
        self.need_data = True
        self.clients_connected = 0
        
        # GStreamer Ï¥àÍ∏∞Ìôî - Ïä§Î†àÎìú ÏïàÏ†ÑÏÑ±ÏùÑ ÏúÑÌï¥ Î©îÏù∏ Ïä§Î†àÎìúÏóêÏÑú ÏàòÌñâ
        if not Gst.is_initialized():
            Gst.init(None)
        
        print(f"GStreamer RTSP ÏÑúÎ≤Ñ Ï¥àÍ∏∞Ìôî - Port: {port}, Mount: {mount_point}")
    
    def create_pipeline(self):
        """üöÄ FPS Ï†ÅÏùëÌòï Ï†ÄÏßÄÏó∞ RTSP ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ±"""
        # Ïã§Ï†ú ÌîÑÎ†àÏûÑÎ†àÏù¥Ìä∏Ïóê ÎßûÏ∂ò ÎèôÏ†Å FPS ÏÑ§Ï†ï
        pipeline_str = (
            "( appsrc name=source is-live=true block=false format=GST_FORMAT_TIME "
            "do-timestamp=true min-latency=0 max-latency=0 "
            "max-bytes=0 max-buffers=2 "
            "caps=video/x-raw,format=BGRx,width=640,height=640,framerate=10/1 ! "
            "queue max-size-buffers=2 max-size-time=0 max-size-bytes=0 leaky=downstream ! "
            "videoconvert ! video/x-raw,format=I420 ! "
            "queue max-size-buffers=1 max-size-time=0 max-size-bytes=0 leaky=downstream ! "
            "x264enc speed-preset=superfast tune=zerolatency bitrate=800 threads=2 "
            "key-int-max=10 bframes=0 aud=false cabac=false dct8x8=false ! "
            "queue max-size-buffers=1 max-size-time=0 max-size-bytes=0 leaky=downstream ! "
            "rtph264pay config-interval=1 mtu=1400 name=pay0 pt=96 )"
        )
        return pipeline_str
    
    def start_server(self):
        """RTSP ÏÑúÎ≤Ñ ÏãúÏûë"""
        try:
            self.server = GstRtspServer.RTSPServer()
            self.server.set_service(str(self.port))
            
            self.factory = GstRtspServer.RTSPMediaFactory()
            self.factory.set_launch(self.create_pipeline())
            self.factory.set_shared(True)
            
            # ÎØ∏ÎîîÏñ¥ Ìå©ÌÜ†Î¶¨Ïóê ÏΩúÎ∞± Ïó∞Í≤∞
            self.factory.connect("media-configure", self.on_media_configure)
            
            mount_points = self.server.get_mount_points()
            mount_points.add_factory(self.mount_point, self.factory)
            
            self.server.attach(None)
            
            # GLib Î©îÏù∏ Î£®ÌîÑÎ•º Î≥ÑÎèÑ Ïä§Î†àÎìúÏóêÏÑú Ïã§Ìñâ
            self.start_glib_loop()
            
            self.running = True
            
            print(f"RTSP ÏÑúÎ≤Ñ ÏãúÏûëÎê® - rtsp://localhost:{self.port}{self.mount_point}")
            return True
            
        except Exception as e:
            print(f"RTSP ÏÑúÎ≤Ñ ÏãúÏûë Ïã§Ìå®: {e}")
            traceback.print_exc()
            return False
    
    def start_glib_loop(self):
        """GLib Î©îÏù∏ Î£®ÌîÑÎ•º Î≥ÑÎèÑ Ïä§Î†àÎìúÏóêÏÑú ÏãúÏûë"""
        def glib_loop():
            try:
                # GLib Ïª®ÌÖçÏä§Ìä∏ ÏÑ§Ï†ï
                context = GLib.MainContext.new()
                GLib.MainContext.push_thread_default(context)
                
                self.mainloop = GLib.MainLoop.new(context, False)
                self.mainloop.run()
            except Exception as e:
                print(f"GLib Î©îÏù∏ Î£®ÌîÑ Ïò§Î•ò: {e}")
            finally:
                # Ïª®ÌÖçÏä§Ìä∏ Ï†ïÎ¶¨
                try:
                    GLib.MainContext.pop_thread_default()
                except:
                    pass
        
        import threading
        self.glib_thread = threading.Thread(target=glib_loop, daemon=True)
        self.glib_thread.start()
        print("GLib Î©îÏù∏ Î£®ÌîÑ ÏãúÏûëÎê®")
    
    def on_media_configure(self, factory, media):
        """ÎØ∏ÎîîÏñ¥Í∞Ä Íµ¨ÏÑ±Îê† Îïå Ìò∏Ï∂úÎêòÎäî ÏΩúÎ∞±"""
        print("[GStreamerRTSPServer] on_media_configure Ìò∏Ï∂úÎê®")
        try:
            element = media.get_element()
            if element:
                self.appsrc = element.get_by_name("source")
                if self.appsrc:
                    print("appsrc Ïó∞Í≤∞ ÏÑ±Í≥µ")
                    
                    # üöÄ ÏµúÏ†ÅÌôîÎêú appsrc ÏÜçÏÑ± ÏÑ§Ï†ï
                    self.appsrc.set_property("is-live", True)
                    self.appsrc.set_property("block", False)  # ÎÖºÎ∏îÎ°úÌÇπ Î™®Îìú
                    self.appsrc.set_property("format", Gst.Format.TIME)
                    self.appsrc.set_property("emit-signals", False)  # ÏãúÍ∑∏ÎÑê ÎπÑÌôúÏÑ±ÌôîÎ°ú ÏÑ±Îä• Ìñ•ÏÉÅ
                    self.appsrc.set_property("do-timestamp", True)  # ÏûêÎèô ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ
                    self.appsrc.set_property("max-bytes", 0)  # Î∞îÏù¥Ìä∏ Ï†úÌïú ÏóÜÏùå
                    self.appsrc.set_property("max-buffers", 2)  # ÏµúÎåÄ 2Í∞ú Î≤ÑÌçº
                    
                    # üéØ Ï†ÅÏùëÌòï Ï∫°Ïä§ ÏÑ§Ï†ï - Ïã§Ï†ú FPSÏóê ÎßûÏ∂§
                    caps = Gst.Caps.from_string("video/x-raw,format=BGRx,width=640,height=640,framerate=10/1")
                    self.appsrc.set_property("caps", caps)
                    
                    self.clients_connected += 1
                    print(f"ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞Îê® (Ï¥ù {self.clients_connected}Í∞ú)")
                else:
                    print("appsrc Ï∞æÍ∏∞ Ïã§Ìå®")
            else:
                print("ÎØ∏ÎîîÏñ¥ ÏóòÎ¶¨Î®ºÌä∏ Ï∞æÍ∏∞ Ïã§Ìå®")
        except Exception as e:
            print(f"ÎØ∏ÎîîÏñ¥ Íµ¨ÏÑ± Ïò§Î•ò: {e}")
            traceback.print_exc()
    
    def on_need_data(self, src, length):
        """Îç∞Ïù¥ÌÑ∞Í∞Ä ÌïÑÏöîÌï† Îïå Ìò∏Ï∂ú"""
        print(f"[GStreamerRTSPServer] on_need_data Ìò∏Ï∂úÎê®, ÏöîÏ≤≠ Í∏∏Ïù¥: {length}, ÌòÑÏû¨ need_data: {self.need_data}")
        self.need_data = True
        print(f"[GStreamerRTSPServer] on_need_data Ïù¥ÌõÑ need_data: {self.need_data}")
        
    def on_enough_data(self, src):
        """Ï∂©Î∂ÑÌïú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÏùÑ Îïå Ìò∏Ï∂ú"""
        print(f"[GStreamerRTSPServer] on_enough_data Ìò∏Ï∂úÎê®, ÌòÑÏû¨ need_data: {self.need_data}")
        self.need_data = False
        print(f"[GStreamerRTSPServer] on_enough_data Ïù¥ÌõÑ need_data: {self.need_data}")
    
    def push_frame(self, frame):
        """üéØ Ï†ÅÏùëÌòï FPS Í∏∞Î∞ò ÌîÑÎ†àÏûÑ Ìë∏Ïãú"""
        try:
            if not self.running or self.appsrc is None:
                return False

            if frame is None:
                print("[GStreamerRTSPServer] push_frame: Îπà ÌîÑÎ†àÏûÑ ÏàòÏã†. Ïä§ÌÇµ.")
                return False

            # BGR ‚Üí BGRx Î≥ÄÌôò
            frame_bgrx = cv2.cvtColor(frame, cv2.COLOR_BGR2BGRA)
            data = frame_bgrx.tobytes()
            buf = Gst.Buffer.new_allocate(None, len(data), None)
            buf.fill(0, data)
            
            # üöÄ Ìñ•ÏÉÅÎêú ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ Í¥ÄÎ¶¨
            current_time = time.time()
            
            if not hasattr(self, 'stream_start_time'):
                self.stream_start_time = current_time
                self.frame_counter = 0
                self.target_fps = 10.0  # Î™©Ìëú FPS
                self.frame_duration = 1.0 / self.target_fps * Gst.SECOND  # ÎÇòÎÖ∏Ï¥à
                
            # ÌîÑÎ†àÏûÑ Î≤àÌò∏ Í∏∞Î∞ò PTS Í≥ÑÏÇ∞ (ÏùºÏ†ïÌïú Í∞ÑÍ≤© Î≥¥Ïû•)
            self.frame_counter += 1
            buf.pts = int(self.frame_counter * self.frame_duration)
            buf.duration = int(self.frame_duration)
            
            # Ïã§Ï†ú ÏãúÍ∞ÑÍ≥º Ïä§Ìä∏Î¶º ÏãúÍ∞Ñ Ï∞®Ïù¥ Î™®ÎãàÌÑ∞ÎßÅ
            stream_time = buf.pts / Gst.SECOND
            real_time = current_time - self.stream_start_time
            time_diff = abs(stream_time - real_time)
            
            # 5Ï¥à Ïù¥ÏÉÅ Ï∞®Ïù¥ÎÇòÎ©¥ Î¶¨ÏÖã
            if time_diff > 5.0:
                print(f"[GStreamerRTSPServer] ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ Î¶¨ÏÖã (Ï∞®Ïù¥: {time_diff:.2f}Ï¥à)")
                self.stream_start_time = current_time
                self.frame_counter = 1
                buf.pts = int(self.frame_duration)
            
            retval = self.appsrc.emit('push-buffer', buf)
            
            if retval != Gst.FlowReturn.OK:
                if retval == Gst.FlowReturn.FLUSHING:
                    # Ï†ïÏÉÅÏ†ÅÏù∏ Ï¢ÖÎ£å ÏÉÅÌô©
                    return False
                else:
                    print(f"[GStreamerRTSPServer] push-buffer Ïã§Ìå®: {retval}")
                    return False
            
            # 20ÌîÑÎ†àÏûÑÎßàÎã§ ÌÉÄÏù¥Î∞ç Ï†ïÎ≥¥ Ï∂úÎ†•
            if self.frame_counter % 20 == 0:
                print(f"[Ïä§Ìä∏Î¶º] ÌîÑÎ†àÏûÑ {self.frame_counter}, PTS: {stream_time:.2f}s, Ïã§ÏãúÍ∞Ñ: {real_time:.2f}s")
            
            return True
                
        except Exception as e:
            print(f"[GStreamerRTSPServer] push_frame Ïò§Î•ò: {e}")
            return False
    
    def stop_server(self):
        """RTSP ÏÑúÎ≤Ñ Ï§ëÏßÄ"""
        if self.running:
            self.running = False
            print("RTSP ÏÑúÎ≤Ñ Ï§ëÏßÄ ÏãúÏûë...")
            
            # appsrc Ï†ïÎ¶¨
            if self.appsrc:
                try:
                    self.appsrc.emit("end-of-stream")
                    print("appsrc end-of-stream Ï†ÑÏÜ° ÏôÑÎ£å")
                except Exception as e:
                    print(f"appsrc Ï†ïÎ¶¨ Ïò§Î•ò: {e}")
            
            # GLib Î©îÏù∏ Î£®ÌîÑ Ï†ïÎ¶¨
            if self.mainloop:
                try:
                    # Î©îÏù∏ Î£®ÌîÑÎ•º ÏïàÏ†ÑÌïòÍ≤å Ï¢ÖÎ£åÌïòÍ∏∞ ÏúÑÌïú idle Ìï®Ïàò Ï∂îÍ∞Ä
                    def quit_mainloop():
                        self.mainloop.quit()
                        return False  # Ìïú Î≤àÎßå Ïã§Ìñâ
                    
                    GLib.idle_add(quit_mainloop)
                    
                    # Ïä§Î†àÎìúÍ∞Ä Ï¢ÖÎ£åÎê† ÎïåÍπåÏßÄ Ïû†Ïãú ÎåÄÍ∏∞
                    if hasattr(self, 'glib_thread') and self.glib_thread.is_alive():
                        self.glib_thread.join(timeout=2.0)
                        
                    print("GLib Î©îÏù∏ Î£®ÌîÑ Ï¢ÖÎ£å ÏôÑÎ£å")
                except Exception as e:
                    print(f"GLib Î©îÏù∏ Î£®ÌîÑ Ï¢ÖÎ£å Ïò§Î•ò: {e}")
                    
            print("RTSP ÏÑúÎ≤Ñ Ï§ëÏßÄ ÏôÑÎ£å")
    
    def get_rtsp_url(self):
        """RTSP URL Î∞òÌôò"""
        return f"rtsp://spcwtech.mooo.com:{self.port}{self.mount_point}"

class KeyboardController:
    def __init__(self, serial_port=None, baudrate=115200):
        try:
            if isinstance(serial_port, str):
                # ÏãúÎ¶¨Ïñº Ìè¨Ìä∏ Í≤ΩÎ°úÍ∞Ä Î¨∏ÏûêÏó¥Î°ú Ï£ºÏñ¥ÏßÑ Í≤ΩÏö∞
                self.ser = serial.Serial(serial_port, baudrate, timeout=1)
            elif hasattr(serial_port, 'write'):
                # Ïù¥ÎØ∏ Ï¥àÍ∏∞ÌôîÎêú ÏãúÎ¶¨Ïñº Ìè¨Ìä∏ Í∞ùÏ≤¥Í∞Ä Ï£ºÏñ¥ÏßÑ Í≤ΩÏö∞
                self.ser = serial_port
            else:
                # Í∏∞Î≥∏ Ìè¨Ìä∏ ÏãúÎèÑ
                self.ser = serial.Serial('/dev/ttyS3', baudrate, timeout=1)
            self.running = True
        except Exception as e:
            print(f"ÌÇ§Î≥¥Îìú Ïª®Ìä∏Î°§Îü¨ ÏãúÎ¶¨Ïñº Ìè¨Ìä∏ Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")
            self.ser = None
            self.running = False
        
        self.interrupt_flag = False

    def on_press(self, key):
        if not PYNPUT_AVAILABLE:
            return True
            
        try:
            command = None
            
            if hasattr(key, 'char'):
                if key.char == 'w':
                    command = 'up'
                elif key.char == 's':
                    command = 'down'
                elif key.char == 'a':
                    command = 'left'
                elif key.char == 'd':
                    command = 'right'
                elif key.char == 'q':
                    self.running = False
                    self.interrupt_flag = True
                    return False
            elif PYNPUT_AVAILABLE and hasattr(keyboard, 'Key') and key == keyboard.Key.esc:
                self.running = False
                self.interrupt_flag = True
                return False
                
            if command and self.ser and self.ser.is_open:
                try:
                    self.ser.write(f"{command}\n".encode())
                except Exception as e:
                    pass
                
        except Exception as e:
            traceback.print_exc()
            
        return True

    def start(self):
        if not PYNPUT_AVAILABLE:
            print("\n‚ö†Ô∏è  ÌÇ§Î≥¥Îìú Ïª®Ìä∏Î°§ ÎπÑÌôúÏÑ±Ìôî (headless ÌôòÍ≤Ω)")
            print("MQTTÎ•º ÌÜµÌïú ÏõêÍ≤© Ï†úÏñ¥Îßå ÏÇ¨Ïö© Í∞ÄÎä•Ìï©ÎãàÎã§.")
            return
            
        print("\nÌÇ§Î≥¥Îìú Ïª®Ìä∏Î°§ ÏãúÏûë")
        print("WASD ÌÇ§Î•º ÏÇ¨Ïö©ÌïòÏó¨ Ï†úÏñ¥ÌïòÏÑ∏Ïöî:")
        print("W - ÏúÑÎ°ú Ïù¥Îèô")
        print("A - ÏôºÏ™ΩÏúºÎ°ú Ïù¥Îèô")
        print("S - ÏïÑÎûòÎ°ú Ïù¥Îèô")
        print("D - Ïò§Î•∏Ï™ΩÏúºÎ°ú Ïù¥Îèô")
        print("Ï¢ÖÎ£å: Q ÎòêÎäî ESC")
        
        self.keyboard_thread = threading.Thread(target=self._keyboard_listener)
        self.keyboard_thread.daemon = True
        self.keyboard_thread.start()

    def _keyboard_listener(self):
        try:
            fd = sys.stdin.fileno()
            old_settings = termios.tcgetattr(fd)
            
            try:
                tty.setraw(fd)
                
                while self.running and not self.interrupt_flag:
                    r, w, e = select.select([sys.stdin], [], [], 0.1)
                    if r:
                        key = sys.stdin.read(1)
                        
                        if not self._process_key(key):
                            break
                            
            finally:
                termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
                
        except Exception as e:
            traceback.print_exc()
            self.interrupt_flag = True

    def _process_key(self, key):
        try:
            command = None
            
            if key == '\x1b':  # ESC ÌÇ§
                next1 = sys.stdin.read(1)
                if next1 == '[':
                    next2 = sys.stdin.read(1)
                    
                    if next2 == 'A':  # ÏúÑÏ™Ω ÌôîÏÇ¥Ìëú
                        command = 'up'
                    elif next2 == 'B':  # ÏïÑÎûòÏ™Ω ÌôîÏÇ¥Ìëú
                        command = 'down'
                    elif next2 == 'D':  # ÏôºÏ™Ω ÌôîÏÇ¥Ìëú
                        command = 'left'
                    elif next2 == 'C':  # Ïò§Î•∏Ï™Ω ÌôîÏÇ¥Ìëú
                        command = 'right'
                else:
                    self.running = False
                    self.interrupt_flag = True
                    return False
            
            elif key == 'q':
                self.running = False
                self.interrupt_flag = True
                return False
            
            if command and self.ser and self.ser.is_open:
                try:
                    self.ser.write(f"{command}\n".encode())
                except Exception as e:
                    pass
            
            return True
        
        except Exception as e:
            traceback.print_exc()
            return True

    def stop(self):
        print("ÌÇ§Î≥¥Îìú Ïª®Ìä∏Î°§Îü¨ Ï¢ÖÎ£å Ï§ë...")
        self.running = False
        # ÏãúÎ¶¨Ïñº Ìè¨Ìä∏Îäî Îã§Î•∏ Ïª¥Ìè¨ÎÑåÌä∏ÏôÄ Í≥µÏú†Ìï† Ïàò ÏûàÏúºÎØÄÎ°ú Îã´ÏßÄ ÏïäÏùå
        # Ï£º ÌîÑÎ°úÍ∑∏Îû®ÏóêÏÑú Ï†ïÎ¶¨Îê®

class DeepSORTTracker:
    def __init__(self, model_path='/home/spcwtech/mars-small128.pb', 
                 max_cosine_distance=0.4, nn_budget=None):
        """Initialize DeepSORT tracker with feature extractor and matching parameters"""
        print("DeepSORT Ìä∏ÎûòÏª§ Ï¥àÍ∏∞Ìôî Ï§ë...")
        
        # DeepSORT ÌäπÏßï Ï∂îÏ∂úÍ∏∞ Ï¥àÍ∏∞Ìôî
        self.encoder = gdet.create_box_encoder(model_path, batch_size=1)
        print("DeepSORT ÌäπÏßï Ï∂îÏ∂úÍ∏∞ Î°úÎìú ÏôÑÎ£å")
        
        # Create a tracker
        metric = nn_matching.NearestNeighborDistanceMetric("cosine", max_cosine_distance, nn_budget)
        self.tracker = Tracker(metric, max_age=60)
        print("DeepSORT Ìä∏ÎûòÏª§ ÏÉùÏÑ± ÏôÑÎ£å")
        
        # Track history for visualization
        self.track_history = {}  # Ìä∏Îûô ID -> ÏúÑÏπò Î™©Î°ù ÎîïÏÖîÎÑàÎ¶¨
        self.max_history_len = 30  # ÏµúÎåÄ ÌûàÏä§ÌÜ†Î¶¨ Í∏∏Ïù¥
        
        # Color map for visualization
        self.color_map = {}  # Ìä∏Îûô ID -> ÏÉâÏÉÅ ÎîïÏÖîÎÑàÎ¶¨
        self.track_class_map = {}

    def update(self, frame, detections):
        """Update tracker with new detections"""
        if len(detections) == 0:
            self.tracker.predict()
            print("DeepSORT: Í∞êÏßÄÎêú Í∞ùÏ≤¥ ÏóÜÏùå, Ìä∏ÎûòÏª§ ÏòàÏ∏°Îßå ÏàòÌñâ")
            return []
        
        # Extract bounding boxes, scores and class IDs
        boxes = []
        scores = []
        class_ids = []
        class_ids_dict = {}
        for det in detections:
            x, y, w, h, score, class_id = det
            # Convert x,y,w,h to x1,y1,x2,y2 format
            x1 = int(max(0, x - w/2))
            y1 = int(max(0, y - h/2))
            x2 = int(min(frame.shape[1]-1, x + w/2))
            y2 = int(min(frame.shape[0]-1, y + h/2))
            
            boxes.append([x1, y1, x2 - x1, y2 - y1])  # [x, y, width, height]
            scores.append(score)
            class_ids.append(int(class_id))
        
        # Convert to numpy arrays
        boxes = np.array(boxes)
        scores = np.array(scores)
        class_ids = np.array(class_ids)
        
        # Extract features
        print(f"DeepSORT: {len(boxes)} Í∞ùÏ≤¥Ïóê ÎåÄÌïú ÌäπÏßï Ï∂îÏ∂ú Ï§ë...")
        features = self.encoder(frame, boxes)
        print("DeepSORT: ÌäπÏßï Ï∂îÏ∂ú ÏôÑÎ£å")
        
        # Create detections for DeepSORT
        detections_for_tracker = []
        for i in range(len(boxes)):
            det = Detection(boxes[i], scores[i], features[i], class_ids[i])
            detections_for_tracker.append(det)
        
        # Update tracker
        self.tracker.predict()
        self.tracker.update(detections_for_tracker)
        print(f"DeepSORT: Ìä∏ÎûòÏª§ ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å, ÌòÑÏû¨ Ìä∏Îûô Ïàò: {len(self.tracker.tracks)}")
        
        # Prepare tracking results for visualization
        results = []
        for track in self.tracker.tracks:
            if not track.is_confirmed() or track.time_since_update > 1:
                continue
            
            bbox = track.to_tlbr()  # Get current position in format [x1,y1,x2,y2]
            track_id = track.track_id
            center_x = (bbox[0] + bbox[2]) / 2
            center_y = (bbox[1] + bbox[3]) / 2
            w = bbox[2] - bbox[0]
            h = bbox[3] - bbox[1]
            closest_class_id = None
            min_dist = float('inf')
            
            for (det_x, det_y, det_w, det_h), det_class_id in class_ids_dict.items():
                # Ï§ëÏã¨Ï†ê Í±∞Î¶¨ Í≥ÑÏÇ∞
                det_center_x = det_x
                det_center_y = det_y
                dist = ((center_x - det_center_x) ** 2 + (center_y - det_center_y) ** 2) ** 0.5
                
                if dist < min_dist:
                    min_dist = dist
                    closest_class_id = det_class_id
            
            # ÏùºÏ†ï Í±∞Î¶¨ ÎÇ¥Ïóê ÎîîÌÖçÏÖòÏù¥ ÏûàÏúºÎ©¥ ÌÅ¥ÎûòÏä§ ID ÏóÖÎç∞Ïù¥Ìä∏
            if min_dist < (w + h) / 2:  # Î∞ïÏä§ ÌÅ¨Í∏∞ Í∏∞Î∞ò ÏûÑÍ≥ÑÍ∞í
                self.track_class_map[track_id] = closest_class_id
            
            # Ï†ÄÏû•Îêú ÌÅ¥ÎûòÏä§ ID ÏÇ¨Ïö©
            class_id = self.track_class_map.get(track_id, 0)  # Í∏∞Î≥∏Í∞í 0
            
            # Í≤∞Í≥º Ï†ÄÏû•
            results.append((bbox, track_id, class_id))
        
        # ÎπÑÌôúÏÑ± Ìä∏ÎûôÏùò ÌÅ¥ÎûòÏä§ ID Îß§Ìïë Ï†ïÎ¶¨
        active_track_ids = {track.track_id for track in self.tracker.tracks if track.is_confirmed()}
        for track_id in list(self.track_class_map.keys()):
            if track_id not in active_track_ids:
                del self.track_class_map[track_id]
        
        return results
    
    def draw_tracks(self, frame, tracks, class_names=None):
        """Draw tracks on the frame"""
        for bbox, track_id, class_id in tracks:
            x1, y1, x2, y2 = bbox.astype(int)
            
            # Get color for this track
            if track_id not in self.color_map:
                # ÏÉàÎ°úÏö¥ Ìä∏ÎûôÏóê ÎåÄÌï¥ Í≥†Ïú†Ìïú ÏÉâÏÉÅ ÏÉùÏÑ±
                import random
                self.color_map[track_id] = (
                    random.randint(50, 255), 
                    random.randint(50, 255), 
                    random.randint(50, 255)
                )
            color = self.color_map[track_id]
            
            # Draw bounding box
            cv2.rectangle(frame, (x1, y1), (x2, y2), color, 2)
            
            # ÌÅ¥ÎûòÏä§ Ïù¥Î¶Ñ Ï§ÄÎπÑ
            class_name = "unknown"
            if class_names and class_id < len(class_names):
                class_name = class_names[class_id]
            elif class_id is not None:
                class_name = f"class_{class_id}"
            
            # Draw track ID and class name
            label = f"ID:{track_id} {class_name}"
            label_size = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 2)[0]
            cv2.rectangle(frame, (x1, y1 - label_size[1] - 5), (x1 + label_size[0], y1), color, -1)
            cv2.putText(frame, label, (x1, y1 - 5), 
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 2)
            
            # Ï§ëÏã¨Ï†ê ÌëúÏãú
            center_x = int((x1 + x2) / 2)
            center_y = int((y1 + y2) / 2)
            cv2.circle(frame, (center_x, center_y), 3, color, -1)
            
            # Draw track history
            if track_id in self.track_history:
                history = self.track_history[track_id]
                for i in range(1, len(history)):
                    if history[i-1] is None or history[i] is None:
                        continue
                    # Draw line between consecutive positions
                    thickness = int(np.sqrt(self.max_history_len / float(i + 1)) * 2)
                    cv2.line(frame, history[i-1], history[i], color, thickness)
            
            # ÌòÑÏû¨ ÏúÑÏπòÎ•º ÌûàÏä§ÌÜ†Î¶¨Ïóê Ï∂îÍ∞Ä
            if track_id not in self.track_history:
                self.track_history[track_id] = []
            
            self.track_history[track_id].append((center_x, center_y))
            
            # ÌûàÏä§ÌÜ†Î¶¨ Í∏∏Ïù¥ Ï†úÌïú
            if len(self.track_history[track_id]) > self.max_history_len:
                self.track_history[track_id].pop(0)
        
        return frame

class RKNNDetector:
    def __init__(self, model_path='/home/spcwtech/yolo5n_fish-rk3566.rknn', 
                 mqtt_broker='localhost', mqtt_port=1883):
        self.rknn = RKNN()
        try:
            ret = self.rknn.load_rknn(model_path)
            if ret != 0:
                print('Load RKNN model failed')
                exit(ret)
                
            ret = self.rknn.init_runtime()
            if ret != 0:
                print('Init runtime environment failed')
                exit(ret)
        except Exception as e:
            traceback.print_exc()
            
        self.input_size = 640
        
        # üöÄ ÏÑ±Îä• ÏµúÏ†ÅÌôî: DeepSORT ÎπÑÌôúÏÑ±Ìôî
        self.enable_deepsort = False  # DeepSORT ÏôÑÏ†Ñ ÎπÑÌôúÏÑ±Ìôî
        if self.enable_deepsort:
            # Initialize DeepSORT tracker
            self.deep_sort = DeepSORTTracker()
            print("DeepSORT Ìä∏ÎûòÏª§ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
        else:
            self.deep_sort = None
            print("üöÄ ÏÑ±Îä• ÏµúÏ†ÅÌôî: DeepSORT ÎπÑÌôúÏÑ±ÌôîÎê®")
        
        # üöÄ ÏÑ±Îä• ÏµúÏ†ÅÌôî: ÌîÑÎ†àÏûÑ Ïä§ÌÇµ ÏÑ§Ï†ï
        self.frame_skip = 3  # Îß§ 3Î≤àÏß∏ ÌîÑÎ†àÏûÑÎßå Ï≤òÎ¶¨
        self.frame_counter = 0
        
        # Initialize GStreamer RTSP server
        self.gst_server = GStreamerRTSPServer(port=7200, mount_point="/test")
        self.gst_server.start_server()
        
        # Initialize MQTT client with GStreamer server reference
        self.mqtt_client = MQTTClient(
            broker_host=mqtt_broker, 
            broker_port=mqtt_port,
            gst_server=self.gst_server
        )
        
        # Ïπ¥Î©îÎùº Ïù¥Îèô ÏΩúÎ∞± ÏÑ§Ï†ï
        self.mqtt_client.set_move_callback(self.handle_move_command)
        self.mqtt_client.connect()
        
        # ÏãúÎ¶¨Ïñº Ìè¨Ìä∏ (Ïπ¥Î©îÎùº Ïù¥ÎèôÏö©)
        self.serial_port = None
        self.init_serial_port()
        
        try:
            with open("coco.names", "r") as f:
                self.classes = [line.strip() for line in f.readlines()]
        except FileNotFoundError:
            self.classes = [f"class_{i}" for i in range(80)]

        # Detection data tracking for MQTT
        self.detection_send_interval = 5.0  # 5Ï¥àÎßàÎã§ Ï†ÑÏÜ°
        self.last_mqtt_send = time.time()
        self.last_detections = []  # ÏµúÍ∑º Í∞êÏßÄÎêú Í∞ùÏ≤¥Îì§

    def init_serial_port(self):
        """ÏãúÎ¶¨Ïñº Ìè¨Ìä∏ Ï¥àÍ∏∞Ìôî (Ïπ¥Î©îÎùº Ïù¥ÎèôÏö©)"""
        serial_ports = ['/dev/ttyS3', '/dev/ttyS0', '/dev/ttyAMA0', '/dev/ttyUSB0']
        
        for port in serial_ports:
            try:
                self.serial_port = serial.Serial(port, 115200, timeout=1)
                if self.serial_port.is_open:
                    print(f"ÏãúÎ¶¨Ïñº Ìè¨Ìä∏ {port} Ïó∞Í≤∞ ÏÑ±Í≥µ!")
                    break
                else:
                    self.serial_port = None
            except Exception as e:
                self.serial_port = None
                continue
        
        if self.serial_port is None:
            print("ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÏãúÎ¶¨Ïñº Ìè¨Ìä∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")

    def handle_move_command(self, command):
        """MQTTÎ°ú Î∞õÏùÄ Ïπ¥Î©îÎùº Ïù¥Îèô Î™ÖÎ†π Ï≤òÎ¶¨"""
        try:
            print(f"Ïπ¥Î©îÎùº Ïù¥Îèô Î™ÖÎ†π ÏàòÏã†: {command}")
            
            if self.serial_port and self.serial_port.is_open:
                # Î™ÖÎ†πÏñ¥ Îß§Ìïë
                move_commands = {
                    "up": "up",
                    "down": "down", 
                    "left": "left",
                    "right": "right",
                    "stop": "stop"
                }
                
                if command in move_commands:
                    serial_command = f"{move_commands[command]}\n"
                    self.serial_port.write(serial_command.encode())
                    print(f"ÏãúÎ¶¨Ïñº Î™ÖÎ†π Ï†ÑÏÜ°: {serial_command.strip()}")
                else:
                    print(f"Ïïå Ïàò ÏóÜÎäî Ïù¥Îèô Î™ÖÎ†π: {command}")
            else:
                print("ÏãúÎ¶¨Ïñº Ìè¨Ìä∏Í∞Ä Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏùå")
                
        except Exception as e:
            print(f"Ïù¥Îèô Î™ÖÎ†π Ï≤òÎ¶¨ Ïò§Î•ò: {e}")

    def decode_predictions(self, output, conf_thres=0.20, max_score=0.95):
        try:
            pred = output[0].squeeze().transpose(1, 0)
            boxes_raw = pred[:, :4]
            objectness = pred[:, 4] * 10
            class_probs = pred[:, 5:] * 2
            class_conf = np.max(class_probs, axis=1)
            class_ids = np.argmax(class_probs, axis=1)
            scores = objectness + class_conf 
            mask = (scores > conf_thres) & (scores <= max_score)
            boxes_xywh = boxes_raw[mask]
            scores_filtered = scores[mask]
            class_ids_filtered = class_ids[mask]
            
            if len(boxes_xywh) == 0:
                return np.array([])
            
            detections = np.column_stack([
                boxes_xywh,
                scores_filtered,
                class_ids_filtered
            ])
            
            return detections
        except Exception as e:
            return np.array([])

    def apply_nms(self, detections, iou_thres=0.35):
        try:
            if len(detections) == 0:
                return []
            
            boxes = detections[:, :4]
            scores = detections[:, 4]
            
            indices = cv2.dnn.NMSBoxes(
                boxes.tolist(), 
                scores.tolist(), 
                score_threshold=0.60,
                nms_threshold=iou_thres
            )
            
            if len(indices) == 0:
                return []
            
            if isinstance(indices, tuple):
                indices = indices[0]
            else:
                indices = indices.flatten()
                
            return detections[indices]
        except Exception as e:
            return []

    def letterbox(self, img, new_shape=(640, 640), color=(114, 114, 114)):
        """Resize and pad image while meeting stride-multiple constraints."""
        shape = img.shape[:2]  # current shape [height, width]
        
        # Scale ratio (new / old)
        r = min(new_shape[0] / shape[0], new_shape[1] / shape[1])
        
        # Compute new unpadded dimensions
        new_unpad = int(round(shape[1] * r)), int(round(shape[0] * r))
        
        # Compute padding
        dw, dh = new_shape[1] - new_unpad[0], new_shape[0] - new_unpad[1]
        
        # Divide padding into 2 sides
        dw /= 2
        dh /= 2
        
        # Resize
        if shape[::-1] != new_unpad:
            img = cv2.resize(img, new_unpad, interpolation=cv2.INTER_LINEAR)
            
        top, bottom = int(round(dh - 0.1)), int(round(dh + 0.1))
        left, right = int(round(dw - 0.1)), int(round(dw + 0.1))
        
        # Add padding
        img = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=color)
        
        return img, r, (dw, dh)

    def detect(self, frame):
        try:
            if frame is None:
                return None

            # üöÄ ÏÑ±Îä• ÏµúÏ†ÅÌôî: ÌîÑÎ†àÏûÑ Ïä§ÌÇµ
            self.frame_counter += 1
            if self.frame_counter % self.frame_skip != 0:
                # Ïä§ÌÇµÎêòÎäî ÌîÑÎ†àÏûÑÏùÄ ÏõêÎ≥∏ Í∑∏ÎåÄÎ°ú Î∞òÌôò
                return frame

            # ÏÑ±Îä• Ï∏°Ï†ï ÏãúÏûë
            total_detect_start = time.time()
            
            draw_frame = frame.copy()

            # 1. Letterbox Î≥ÄÌôò ÏãúÍ∞Ñ Ï∏°Ï†ï
            letterbox_start = time.time()
            img, ratio, pad = self.letterbox(frame, new_shape=(self.input_size, self.input_size))
            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
            img = np.expand_dims(img, axis=0)
            letterbox_time = time.time() - letterbox_start

            # 2. RKNN Ï∂îÎ°† ÏãúÍ∞Ñ Ï∏°Ï†ï
            inference_start = time.time()
            try:
                outputs = self.rknn.inference(inputs=[img])
            except KeyboardInterrupt:
                return draw_frame
            except Exception as e:
                print(f"RKNN Ï∂îÎ°† Ïò§Î•ò: {e}")
                return draw_frame
            inference_time = time.time() - inference_start

            # 3. ÌõÑÏ≤òÎ¶¨ (ÎîîÏΩîÎî© + NMS) ÏãúÍ∞Ñ Ï∏°Ï†ï - üöÄ Îçî ÎÜíÏùÄ ÏûÑÍ≥ÑÍ∞íÏúºÎ°ú ÏµúÏ†ÅÌôî
            postprocess_start = time.time()
            detections = self.decode_predictions(outputs, conf_thres=0.4, max_score=0.95)  # Ïã†Î¢∞ÎèÑ ÎÜíÏûÑ
            detections = self.apply_nms(detections, iou_thres=0.5)  # NMS ÏûÑÍ≥ÑÍ∞í ÎÜíÏûÑ
            postprocess_time = time.time() - postprocess_start
            
            # 4. Ï¢åÌëú Î≥ÄÌôò ÏãúÍ∞Ñ Ï∏°Ï†ï
            coord_transform_start = time.time()
            processed_detections = []
            for det in detections:
                x, y, w, h, score, class_id = det
                # Ìå®Îî© Ï†úÍ±∞ ÌõÑ ÏõêÎ≥∏ ÌÅ¨Í∏∞Î°ú Î≥µÏõê
                x = (x - pad[0]) / ratio
                y = (y - pad[1]) / ratio
                w = w / ratio
                h = h / ratio
                processed_detections.append([x, y, w, h, score, class_id])
            coord_transform_time = time.time() - coord_transform_start
            
            # 5. üöÄ DeepSORT Ìä∏ÎûòÌÇπ ÏµúÏ†ÅÌôî (ÎπÑÌôúÏÑ±Ìôî Í∞ÄÎä•)
            tracking_start = time.time()
            if self.enable_deepsort and self.deep_sort:
                tracks = self.deep_sort.update(frame, processed_detections)
                draw_frame = self.deep_sort.draw_tracks(draw_frame, tracks, self.classes)
            else:
                # DeepSORT ÏóÜÏù¥ Í∞ÑÎã®Ìïú Î∞îÏö¥Îî© Î∞ïÏä§Îßå Í∑∏Î¶¨Í∏∞
                tracks = []
                for detection in processed_detections:
                    x, y, w, h, score, class_id = detection
                    class_id = int(class_id)
                    
                    # Ï§ëÏã¨Ï†ê Ï¢åÌëúÏôÄ ÎÑàÎπÑ, ÎÜíÏù¥Î•º Ï¢åÏÉÅÎã®, Ïö∞ÌïòÎã® Ï¢åÌëúÎ°ú Î≥ÄÌôò
                    x1 = int(max(0, x - w/2))
                    y1 = int(max(0, y - h/2))
                    x2 = int(min(frame.shape[1]-1, x + w/2))
                    y2 = int(min(frame.shape[0]-1, y + h/2))

                    # Î∞ïÏä§Í∞Ä ÎÑàÎ¨¥ ÏûëÏúºÎ©¥ Í±¥ÎÑàÎõ∞Í∏∞
                    if (x2-x1 < 5) or (y2-y1 < 5):
                        continue

                    # Í∞ÑÎã®Ìïú Î∞ïÏä§ÏôÄ ÎùºÎ≤®Îßå Í∑∏Î¶¨Í∏∞
                    class_name = self.classes[class_id] if class_id < len(self.classes) else f"class_{class_id}"
                    color = (0, 255, 0)
                    cv2.rectangle(draw_frame, (x1, y1), (x2, y2), color, 2)
                    
                    label = f"{class_name}: {score:.2f}"
                    cv2.putText(draw_frame, label, (x1, y1-10), 
                               cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 1)
            tracking_time = time.time() - tracking_start
            
            # 6. Í∑∏Î¶¨Í∏∞ ÏãúÍ∞Ñ Ï∏°Ï†ï (Ïù¥ÎØ∏ ÏúÑÏóêÏÑú Ï≤òÎ¶¨Îê®)
            drawing_time = 0
            
            # 7. MQTT Ï†ÑÏÜ° (ÌïÑÏöîÏãú) - üöÄ Ï†ÑÏÜ° Í∞ÑÍ≤© ÎäòÎ¶º
            mqtt_start = time.time()
            current_time = time.time()
            if current_time - self.last_mqtt_send >= self.detection_send_interval * 2:  # Ï†ÑÏÜ° Í∞ÑÍ≤© 2Î∞∞Î°ú
                if self.enable_deepsort and tracks:
                    self.send_tracked_objects_to_mqtt(tracks)
                self.last_mqtt_send = current_time
            mqtt_time = time.time() - mqtt_start
            
            total_detect_time = time.time() - total_detect_start
            
            # ÏÑ±Îä• Ï†ïÎ≥¥ Ï†ÄÏû• (ÌÅ¥ÎûòÏä§ Î≥ÄÏàòÎ°ú)
            if not hasattr(self, 'performance_stats'):
                self.performance_stats = {
                    'letterbox': [],
                    'inference': [],
                    'postprocess': [],
                    'tracking': [],
                    'drawing': [],
                    'total': []
                }
            
            self.performance_stats['letterbox'].append(letterbox_time * 1000)
            self.performance_stats['inference'].append(inference_time * 1000)
            self.performance_stats['postprocess'].append(postprocess_time * 1000)
            self.performance_stats['tracking'].append(tracking_time * 1000)
            self.performance_stats['drawing'].append(drawing_time * 1000)
            self.performance_stats['total'].append(total_detect_time * 1000)
            
            # ÏµúÎåÄ 100Í∞ú Í∏∞Î°ù Ïú†ÏßÄ
            for key in self.performance_stats:
                if len(self.performance_stats[key]) > 100:
                    self.performance_stats[key] = self.performance_stats[key][-100:]
            
            # üöÄ ÏÑ±Îä• Î°úÍ∑∏ Í∞ÑÍ≤© ÎäòÎ¶º (20ÌîÑÎ†àÏûÑÎßàÎã§)
            if hasattr(self, 'frame_counter_log'):
                self.frame_counter_log += 1
            else:
                self.frame_counter_log = 1
                
            if self.frame_counter_log % 20 == 0:
                print(f"\n=== üöÄ ÏµúÏ†ÅÌôîÎêú RKNN ÏÑ±Îä• Î∂ÑÏÑù ===")
                print(f"Í∞êÏßÄÎêú Í∞ùÏ≤¥: {len(processed_detections)}, ÌîÑÎ†àÏûÑ Ïä§ÌÇµ: Îß§ {self.frame_skip}Î≤àÏß∏")
                print(f"DeepSORT: {'ÌôúÏÑ±Ìôî' if self.enable_deepsort else 'ÎπÑÌôúÏÑ±Ìôî (ÏÑ±Îä• ÏµúÏ†ÅÌôî)'}")
                for key, values in self.performance_stats.items():
                    if values:
                        avg_time = sum(values[-10:]) / min(10, len(values))
                        print(f"{key:12}: {avg_time:6.1f}ms")
                        
                        # ÏÑ±Îä• Í≤ΩÍ≥†
                        if key == 'inference' and avg_time > 300:
                            print(f"  ‚ö†Ô∏è  RKNN Ï∂îÎ°†Ïù¥ Ïó¨Ï†ÑÌûà ÎäêÎ¶º: {avg_time:.1f}ms")
                        elif key == 'total' and avg_time > 500:
                            print(f"  ‚ö†Ô∏è  Ï†ÑÏ≤¥ Ï≤òÎ¶¨Í∞Ä Ïó¨Ï†ÑÌûà ÎäêÎ¶º: {avg_time:.1f}ms")
                        elif key == 'total' and avg_time < 100:
                            print(f"  ‚úÖ ÏÑ±Îä• Í∞úÏÑ†Îê®: {avg_time:.1f}ms")
            
            return draw_frame

        except KeyboardInterrupt:
            return frame
        except Exception as e:
            print(f"detect Î©îÏÜåÎìú Ïò§Î•ò: {e}")
            traceback.print_exc()
            return frame 

    def send_tracked_objects_to_mqtt(self, tracks):
        """Ìä∏ÎûòÌÇπÎêú Í∞ùÏ≤¥ Ï†ïÎ≥¥Î•º MQTTÎ°ú Ï†ÑÏÜ°"""
        try:
            if not tracks:
                print("Ï†ÑÏÜ°Ìï† Ìä∏ÎûòÌÇπ Í∞ùÏ≤¥Í∞Ä ÏóÜÏùå")
                return
            
            # Ìä∏ÎûòÌÇπ Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ
            detection_data = []
            for bbox, track_id, class_id in tracks:
                x1, y1, x2, y2 = bbox.astype(int)
                
                # ÌÅ¥ÎûòÏä§ Ïù¥Î¶Ñ Í∞ÄÏ†∏Ïò§Í∏∞
                class_name = self.classes[class_id] if class_id < len(self.classes) else f"class_{class_id}"
                
                obj_info = {
                    "track_id": int(track_id),
                    "class_id": int(class_id),
                    "class_name": class_name,
                    "bbox": {
                        "x1": int(x1),
                        "y1": int(y1), 
                        "x2": int(x2),
                        "y2": int(y2)
                    },
                    "center": {
                        "x": int((x1 + x2) / 2),
                        "y": int((y1 + y2) / 2)
                    }
                }
                detection_data.append(obj_info)
            
            # MQTTÎ°ú Ï†ÑÏÜ°
            if detection_data:
                self.mqtt_client.send_detection_data(detection_data)
                print(f"MQTT Í∞ùÏ≤¥ Ï†ïÎ≥¥ Ï†ÑÏÜ° ÏôÑÎ£å: {len(detection_data)}Í∞ú Í∞ùÏ≤¥")
            
        except Exception as e:
            print(f"MQTT Í∞ùÏ≤¥ Ï†ïÎ≥¥ Ï†ÑÏÜ° Ïã§Ìå®: {e}")
            traceback.print_exc()

    def __del__(self):
        if hasattr(self, 'mqtt_client'):
            try:
                self.mqtt_client.send_status("off")
                self.mqtt_client.disconnect()
            except Exception as e:
                pass
        
        if hasattr(self, 'serial_port') and self.serial_port and self.serial_port.is_open:
            try:
                self.serial_port.close()
            except Exception as e:
                pass
        
        if hasattr(self, 'gst_server'):
            try:
                self.gst_server.stop_server()
            except Exception as e:
                pass
        
        if hasattr(self, 'rknn'):
            try:
                self.rknn.release()
            except Exception as e:
                pass

def find_working_camera():
    """Find the first working video device"""
    # Try mainpath devices first
    for i in range(12):
        device = f'/dev/video{i}'
        print(f"Testing {device}...")
        if test_camera_device(device):
            return device
    
    raise Exception("No working camera found")

# ÏïàÏ†ÑÌïú Ï¢ÖÎ£åÎ•º ÏúÑÌïú Í∏ÄÎ°úÎ≤å ÌîåÎûòÍ∑∏
program_running = True

def main():
    global program_running
    cap = None
    detector = None
    
    # ÌîÑÎ°úÍ∑∏Îû® ÏãúÏûë Ïãú GStreamer Ï¥àÍ∏∞Ìôî (Î©îÏù∏ Ïä§Î†àÎìúÏóêÏÑú)
    print("GStreamer Ï¥àÍ∏∞Ìôî Ï§ë...")
    if not Gst.is_initialized():
        Gst.init(None)
    
    # ÏÑ§Ï†ï ÌååÏùº Î°úÎìú
    config = {
        "mqtt": {
            "broker_host": "localhost",
            "broker_port": 1883,
            "topic_prefix": "camera"
        },
        "gstreamer": {
            "rtsp_port": 7200,
            "mount_point": "/test"
        },
        "detection": {
            "model_path": "/home/spcwtech/yolo5n_fish-rk3566.rknn",
            "send_interval": 5.0
        }
    }
    
    try:
        with open("/home/spcwtech/config.json", "r") as f:
            config.update(json.load(f))
        print("ÏÑ§Ï†ï ÌååÏùº Î°úÎìú ÏôÑÎ£å")
    except FileNotFoundError:
        print("ÏÑ§Ï†ï ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§. Í∏∞Î≥∏ ÏÑ§Ï†ïÏùÑ ÏÇ¨Ïö©Ìï©ÎãàÎã§.")
    except Exception as e:
        print(f"ÏÑ§Ï†ï ÌååÏùº Î°úÎìú Ïã§Ìå®: {e}. Í∏∞Î≥∏ ÏÑ§Ï†ïÏùÑ ÏÇ¨Ïö©Ìï©ÎãàÎã§.")
    
    try:
        video_device = find_working_camera()
        print(f"Found working camera: {video_device}")

        # RKNN ÎîîÌÖçÌÑ∞ Ï¥àÍ∏∞Ìôî
        try:
            detector = RKNNDetector(
                model_path=config["detection"]["model_path"],
                mqtt_broker=config["mqtt"]["broker_host"],
                mqtt_port=config["mqtt"]["broker_port"]
            )
            # MQTTÎ°ú ÏãúÏûë ÏÉÅÌÉú Ï†ÑÏÜ°
            detector.mqtt_client.send_status("start")
        except Exception as e:
            print(f"RKNN ÎîîÌÖçÌÑ∞ Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")
            raise
        
        # ÎßàÏßÄÎßâÏúºÎ°ú Ïπ¥Î©îÎùº Ï¥àÍ∏∞Ìôî
        cap = cv2.VideoCapture(video_device)
        cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
        cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 640)
        
        if not cap.isOpened():
            print(f"Ïπ¥Î©îÎùº {video_device} Ïó¥Í∏∞ Ïã§Ìå®")
            raise Exception("Ïπ¥Î©îÎùºÎ•º Ïó¥ Ïàò ÏóÜÏäµÎãàÎã§")
        
        # OpenCV Ï∞Ω ÏÉùÏÑ± - Î©îÏù∏ Ïä§Î†àÎìúÏóêÏÑúÎßå Ìò∏Ï∂ú
        print("OpenCV Ï∞Ω Ï¥àÍ∏∞Ìôî Ï§ë...")
        try:
            cv2.namedWindow('Object Detection', cv2.WINDOW_NORMAL)
            cv2.resizeWindow('Object Detection', 640, 640)
            print("OpenCV Ï∞Ω Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
        except Exception as e:
            print(f"OpenCV Ï∞Ω Ï¥àÍ∏∞Ìôî Ïò§Î•ò: {e}")
            # Ï∞Ω Ï¥àÍ∏∞Ìôî Ïã§Ìå® ÏãúÏóêÎèÑ Í≥ÑÏÜç ÏßÑÌñâ (headless Î™®Îìú ÏßÄÏõê)
        
        print("Î©îÏù∏ Î£®ÌîÑ ÏãúÏûë")
        program_running = True
        
        # ÌÇ§Î≥¥Îìú Ïª®Ìä∏Î°§Îü¨ Ï¥àÍ∏∞Ìôî Î∞è ÏãúÏûë (MQTTÏôÄ Í≥µÏ°¥)
        # ÏãúÎ¶¨Ïñº Ìè¨Ìä∏Î•º detectorÏôÄ Í≥µÏú†
        keyboard_controller = None
        try:
            keyboard_controller = KeyboardController(serial_port=detector.serial_port)
            keyboard_controller.start()
            if PYNPUT_AVAILABLE:
                print("ÌÇ§Î≥¥Îìú Ïª®Ìä∏Î°§Í≥º MQTT Ï†úÏñ¥Í∞Ä ÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§")
            else:
                print("MQTT Ï†úÏñ¥Îßå ÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§ (ÌÇ§Î≥¥Îìú Ïª®Ìä∏Î°§ ÎπÑÌôúÏÑ±Ìôî)")
        except Exception as e:
            print(f"ÌÇ§Î≥¥Îìú Ïª®Ìä∏Î°§Îü¨ Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")
            print("MQTT Ï†úÏñ¥Îßå ÏÇ¨Ïö©Îê©ÎãàÎã§")
        
        fps_values = []
        fps_alpha = 0.1
        current_fps = 0

        # ÏÑ±Îä• Ï∏°Ï†ï Î≥ÄÏàòÎì§
        timing_history = {
            'frame_capture': [],
            'rknn_inference': [],
            'deepsort_update': [],
            'drawing': [],
            'gstreamer_push': [],
            'total_frame': []
        }
        max_timing_records = 100
        
        frame_count = 0
        loop_start_time = time.time()

        while program_running:
            try:
                # Ï†ÑÏ≤¥ ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨ ÏãúÏûë ÏãúÍ∞Ñ
                total_frame_start = time.time()
                
                # 1. ÌîÑÎ†àÏûÑ Ï∫°Ï≤ò ÏãúÍ∞Ñ Ï∏°Ï†ï
                capture_start = time.time()
                ret, frame = cap.read()
                capture_time = time.time() - capture_start
                
                if not ret:
                    time.sleep(0.1)
                    continue

                # 2. ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨ (RKNN + DeepSORT)
                detect_start = time.time()
                processed_frame = detector.detect(frame)
                detect_time = time.time() - detect_start
                
                if processed_frame is None:
                    continue

                # 3. Ï†ÑÏ≤¥ ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨ ÏãúÍ∞Ñ Í≥ÑÏÇ∞
                total_frame_time = time.time() - total_frame_start
                
                # 4. ÏÑ±Îä• ÌÜµÍ≥Ñ Í∏∞Î°ù
                timing_history['frame_capture'].append(capture_time)
                timing_history['total_frame'].append(total_frame_time)
                
                # ÏµúÎåÄ Í∏∞Î°ù Ïàò Ï†úÌïú
                for key in timing_history:
                    if len(timing_history[key]) > max_timing_records:
                        timing_history[key] = timing_history[key][-max_timing_records:]
                
                # 5. FPS Í≥ÑÏÇ∞ (Ïã§Ï†ú Ï≤òÎ¶¨ ÏãúÍ∞Ñ Í∏∞Î∞ò)
                if total_frame_time > 0:
                    instant_fps = 1 / total_frame_time
                    if current_fps == 0:
                        current_fps = instant_fps
                    else:
                        current_fps = (fps_alpha * instant_fps) + ((1 - fps_alpha) * current_fps)
                
                # 6. ÌîÑÎ†àÏûÑÏóê ÏÑ±Îä• Ï†ïÎ≥¥ ÌëúÏãú
                cv2.putText(processed_frame, f"FPS: {current_fps:.1f}", (10, 30), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
                cv2.putText(processed_frame, f"Frame Time: {total_frame_time*1000:.1f}ms", (10, 60), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1)
                cv2.putText(processed_frame, f"Capture: {capture_time*1000:.1f}ms", (10, 85), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 1)
                cv2.putText(processed_frame, f"Detect: {detect_time*1000:.1f}ms", (10, 110), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 255), 1)
                
                frame_count += 1
                
                # 10ÌîÑÎ†àÏûÑÎßàÎã§ ÏÉÅÏÑ∏ ÏÑ±Îä• Ï†ïÎ≥¥ Ï∂úÎ†•
                if frame_count % 10 == 0:
                    avg_capture = sum(timing_history['frame_capture'][-10:]) / min(10, len(timing_history['frame_capture'])) * 1000
                    avg_total = sum(timing_history['total_frame'][-10:]) / min(10, len(timing_history['total_frame'])) * 1000
                    elapsed_time = time.time() - loop_start_time
                    actual_fps = frame_count / elapsed_time
                    
                    print(f"\n=== ÏÑ±Îä• Î∂ÑÏÑù (ÌîÑÎ†àÏûÑ {frame_count}) ===")
                    print(f"Ïã§Ï†ú ÌèâÍ∑† FPS: {actual_fps:.2f}")
                    print(f"ÌèâÍ∑† ÌîÑÎ†àÏûÑ Ï∫°Ï≤ò ÏãúÍ∞Ñ: {avg_capture:.1f}ms")
                    print(f"ÌèâÍ∑† Ï†ÑÏ≤¥ Ï≤òÎ¶¨ ÏãúÍ∞Ñ: {avg_total:.1f}ms")
                    print(f"Ïù¥Î°†Ï†Å ÏµúÎåÄ FPS: {1000/avg_total:.1f}")
                    
                    if avg_total > 200:  # 200ms Ï¥àÍ≥ºÏãú Í≤ΩÍ≥†
                        print(f"‚ö†Ô∏è  ÏÑ±Îä• Í≤ΩÍ≥†: ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨ ÏãúÍ∞ÑÏù¥ {avg_total:.1f}msÎ°ú ÎÑàÎ¨¥ Í∏∏Ïñ¥ Ïã§ÏãúÍ∞Ñ Ï≤òÎ¶¨Í∞Ä Ïñ¥Î†µÏäµÎãàÎã§.")
                        print("   - RKNN Î™®Îç∏ ÏµúÏ†ÅÌôî ÌïÑÏöî")
                        print("   - DeepSORT ÌååÎùºÎØ∏ÌÑ∞ Ï°∞Ï†ï ÌïÑÏöî")
                        print("   - Ìï¥ÏÉÅÎèÑ ÎÇÆÏ∂îÍ∏∞ Í≥†Î†§")
                    
                    loop_start_time = time.time()
                    frame_count = 0

                # 7. RTSP Ïä§Ìä∏Î¶¨Î∞çÏùÑ ÏúÑÌï¥ ÌîÑÎ†àÏûÑÏùÑ GStreamerÎ°ú Ï†ÑÏÜ°
                gstreamer_start = time.time()
                if detector.gst_server.running:
                    try:
                        # 640x640ÏúºÎ°ú Î¶¨ÏÇ¨Ïù¥Ï¶à (ÌïÑÏöîÏãú)
                        if processed_frame.shape[:2] != (640, 640):
                            stream_frame = cv2.resize(processed_frame, (640, 640))
                        else:
                            stream_frame = processed_frame.copy()
                        
                        # üéØ Í∞úÏÑ†Îêú GStreamer ÌîÑÎ†àÏûÑ Ìë∏Ïãú
                        push_success = detector.gst_server.push_frame(stream_frame)
                        if not push_success and frame_count % 30 == 0:  # 30ÌîÑÎ†àÏûÑÎßàÎã§ Ïã§Ìå® Î°úÍ∑∏
                            print("‚ö†Ô∏è  GStreamer ÌîÑÎ†àÏûÑ Ìë∏Ïãú Ïã§Ìå®")
                    except Exception as e:
                        print(f"RTSP Ïä§Ìä∏Î¶º ÌîÑÎ†àÏûÑ Ï†ÑÏÜ° Ïã§Ìå®: {e}")
                gstreamer_time = time.time() - gstreamer_start
                
                # ÏÑ±Îä• ÌÜµÍ≥ÑÏóê GStreamer ÏãúÍ∞Ñ Ï∂îÍ∞Ä
                timing_history['gstreamer_push'].append(gstreamer_time)
                
                # ÌôîÎ©¥ ÌëúÏãú ÏãúÍ∞Ñ Ï∏°Ï†ï
                display_start = time.time()
                # ÌôîÎ©¥Ïóê ÌëúÏãú - GUI Ïò§Î•ò Î∞©ÏßÄÎ•º ÏúÑÌïú ÏòàÏô∏ Ï≤òÎ¶¨
                try:
                    cv2.imshow('Object Detection', processed_frame)
                except Exception as gui_error:
                    # GUI Ïò§Î•ò Ïãú Î¨¥ÏãúÌïòÍ≥† Í≥ÑÏÜç ÏßÑÌñâ (headless Î™®Îìú ÏßÄÏõê)
                    pass
                display_time = time.time() - display_start
                
                # ÌÇ§ ÏûÖÎ†• Ï≤òÎ¶¨ ÏãúÍ∞Ñ Ï∏°Ï†ï
                input_start = time.time()
                # ÌÇ§ ÏûÖÎ†• Ï≤òÎ¶¨ (OpenCV Ï∞Ω) - GUI Ïò§Î•ò Î∞©ÏßÄ
                try:
                    key = cv2.waitKey(1) & 0xFF
                    if key == ord('q'):
                        program_running = False
                        break
                    elif key == ord('s'):
                        cv2.imwrite("captured_frame.jpg", processed_frame)
                        print("Frame saved to captured_frame.jpg")
                except Exception as key_error:
                    # ÌÇ§ ÏûÖÎ†• Ïò§Î•ò Ïãú Î¨¥ÏãúÌïòÍ≥† Í≥ÑÏÜç ÏßÑÌñâ
                    pass
                input_time = time.time() - input_start
                
                # Ï∂îÍ∞Ä ÏÑ±Îä• Ï†ïÎ≥¥ ÌëúÏãú
                if frame_count % 10 == 0 and len(timing_history['gstreamer_push']) > 0:
                    avg_gstreamer = sum(timing_history['gstreamer_push'][-10:]) / min(10, len(timing_history['gstreamer_push'])) * 1000
                    print(f"GStreamer Ìë∏Ïãú ÌèâÍ∑†: {avg_gstreamer:.1f}ms, ÎîîÏä§ÌîåÎ†àÏù¥: {display_time*1000:.1f}ms")
                    
                    if avg_gstreamer > 50:  # 50ms Ï¥àÍ≥ºÏãú Í≤ΩÍ≥†
                        print(f"‚ö†Ô∏è  GStreamer Ìë∏Ïãú ÏãúÍ∞ÑÏù¥ {avg_gstreamer:.1f}msÎ°ú ÎÑàÎ¨¥ Í∏∏Ïñ¥ Ïä§Ìä∏Î¶¨Î∞ç ÏßÄÏó∞Ïù¥ Î∞úÏÉùÌï† Ïàò ÏûàÏäµÎãàÎã§.")
                
                # üéØ Ïä§ÎßàÌä∏ ÌîÑÎ†àÏûÑ Î†àÏù¥Ìä∏ Ï†úÏñ¥
                target_frame_time = 1.0 / 10.0  # 10 FPS Î™©Ìëú
                if total_frame_time < target_frame_time:
                    sleep_time = target_frame_time - total_frame_time
                    # ÏµúÏÜå 1ms, ÏµúÎåÄ 50ms ÎåÄÍ∏∞
                    sleep_time = max(0.001, min(0.05, sleep_time))
                    time.sleep(sleep_time)
                elif total_frame_time > target_frame_time * 2:
                    # Ï≤òÎ¶¨ ÏãúÍ∞ÑÏù¥ ÎÑàÎ¨¥ Í∏∏Î©¥ Í≤ΩÍ≥†
                    if frame_count % 30 == 0:
                        print(f"‚ö†Ô∏è  ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨ ÏßÄÏó∞: {total_frame_time*1000:.1f}ms (Î™©Ìëú: {target_frame_time*1000:.1f}ms)")

            except KeyboardInterrupt:
                program_running = False
                break
            except Exception as e:
                traceback.print_exc()
                time.sleep(0.5)
                continue

    except KeyboardInterrupt:
        program_running = False
    except Exception as e:
        traceback.print_exc()
    finally:
        print("ÌîÑÎ°úÍ∑∏Îû® Ï¢ÖÎ£å Ï§ë...")
        program_running = False
        
        # ÌÇ§Î≥¥Îìú Ïª®Ìä∏Î°§Îü¨ Ï¢ÖÎ£å
        if 'keyboard_controller' in locals() and keyboard_controller is not None:
            try:
                keyboard_controller.stop()
            except Exception as e:
                pass
        
        # Î¶¨ÏÜåÏä§ Ï†ïÎ¶¨
        if cap and cap.isOpened():
            try:
                cap.release()
                print("Ïπ¥Î©îÎùº Î¶¨ÏÜåÏä§ Ìï¥Ï†ú ÏôÑÎ£å")
            except Exception as e:
                print(f"Ïπ¥Î©îÎùº Î¶¨ÏÜåÏä§ Ìï¥Ï†ú Ïò§Î•ò: {e}")
        
        # OpenCV Ï∞Ω Ï†ïÎ¶¨ - ÏïàÏ†ÑÌïòÍ≤å Ï≤òÎ¶¨
        try:
            cv2.destroyAllWindows()
            print("OpenCV Ï∞Ω Ï†ïÎ¶¨ ÏôÑÎ£å")
        except Exception as e:
            print(f"OpenCV Ï∞Ω Ï†ïÎ¶¨ Ïò§Î•ò: {e}")
        
        if detector:
            try:
                # MQTTÎ°ú Ï¢ÖÎ£å ÏÉÅÌÉú Ï†ÑÏÜ°
                detector.mqtt_client.send_status("stop")
                del detector
                print("ÎîîÌÖçÌÑ∞ Î¶¨ÏÜåÏä§ Ï†ïÎ¶¨ ÏôÑÎ£å")
            except Exception as e:
                print(f"ÎîîÌÖçÌÑ∞ Î¶¨ÏÜåÏä§ Ï†ïÎ¶¨ Ïò§Î•ò: {e}")
        
        print("ÌîÑÎ°úÍ∑∏Îû®Ïù¥ ÏïàÏ†ÑÌïòÍ≤å Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§")

if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        traceback.print_exc()
    finally:
        print("ÌîÑÎ°úÍ∑∏Îû® Ï¢ÖÎ£å")