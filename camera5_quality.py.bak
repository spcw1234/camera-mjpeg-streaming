#!/usr/bin/env python3
"""
ğŸ¯ ê³ í™”ì§ˆ ì‹¤ì‹œê°„ ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¬ë° í”„ë¡œê·¸ë¨
- í™”ì§ˆ ìœ ì§€í•˜ë©´ì„œ ì„±ëŠ¥ ìµœì í™”
- ìŠ¤ë§ˆíŠ¸ ë²„í¼ë§
- ì ì‘í˜• í”„ë ˆì„ ë ˆì´íŠ¸
- GPU ê°€ì† í™œìš©
"""

import cv2
import gi
import threading
import time
import numpy as np
import traceback
import queue
from rknnlite.api import RKNNLite as RKNN

gi.require_version('Gst', '1.0')
gi.require_version('GstRtspServer', '1.0')
from gi.repository import Gst, GstRtspServer, GLib

def find_working_camera():
    """ì‘ë™í•˜ëŠ” ì¹´ë©”ë¼ ì°¾ê¸°"""
    for i in range(12):
        device = f'/dev/video{i}'
        try:
            cap = cv2.VideoCapture(device)
            if cap.isOpened():
                ret, frame = cap.read()
                cap.release()
                if ret and frame is not None:
                    print(f"âœ“ ì¹´ë©”ë¼ ë°œê²¬: {device}")
                    return device
        except:
            continue
    raise Exception("ì‘ë™í•˜ëŠ” ì¹´ë©”ë¼ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")

class HighQualityGStreamerRTSPServer:
    """ê³ í™”ì§ˆ GStreamer RTSP ì„œë²„"""
    def __init__(self, port=7201, mount_point="/hq"):
        self.port = port
        self.mount_point = mount_point
        self.server = None
        self.factory = None
        self.mainloop = None
        self.running = False
        self.appsrc = None
        self.frame_count = 0
        self.frame_queue = queue.Queue(maxsize=3)  # ì‘ì€ íë¡œ ì§€ì—° ìµœì†Œí™”
        
        if not Gst.is_initialized():
            Gst.init(None)
        print(f"ğŸ¯ ê³ í™”ì§ˆ RTSP ì„œë²„ ì´ˆê¸°í™” - Port: {port}")
    
    def create_pipeline(self):
        """ê³ í™”ì§ˆ ìµœì í™” íŒŒì´í”„ë¼ì¸"""
        return (
            "( appsrc name=source is-live=true block=false format=GST_FORMAT_TIME "
            "do-timestamp=true max-buffers=2 drop=true "
            "caps=video/x-raw,format=BGR,width=1280,height=720,framerate=25/1 ! "
            "videoconvert ! video/x-raw,format=I420 ! "
            "x264enc speed-preset=fast tune=zerolatency bitrate=2000 threads=2 "
            "key-int-max=25 bframes=1 ref=1 ! "
            "rtph264pay config-interval=1 mtu=1400 name=pay0 pt=96 )"
        )
    
    def start_server(self):
        """ì„œë²„ ì‹œì‘"""
        try:
            self.server = GstRtspServer.RTSPServer()
            self.server.set_service(str(self.port))
            
            self.factory = GstRtspServer.RTSPMediaFactory()
            self.factory.set_launch(self.create_pipeline())
            self.factory.set_shared(True)
            self.factory.connect("media-configure", self.on_media_configure)
            
            mount_points = self.server.get_mount_points()
            mount_points.add_factory(self.mount_point, self.factory)
            self.server.attach(None)
            
            # GLib ë£¨í”„ ì‹œì‘
            def glib_loop():
                self.mainloop = GLib.MainLoop()
                self.mainloop.run()
            
            self.glib_thread = threading.Thread(target=glib_loop, daemon=True)
            self.glib_thread.start()
            
            self.running = True
            print(f"âœ“ ê³ í™”ì§ˆ RTSP ì„œë²„ ì‹œì‘ - rtsp://spcwtech.mooo.com:{self.port}{self.mount_point}")
            return True
            
        except Exception as e:
            print(f"ì„œë²„ ì‹œì‘ ì‹¤íŒ¨: {e}")
            return False
    
    def on_media_configure(self, factory, media):
        """ë¯¸ë””ì–´ êµ¬ì„±"""
        try:
            element = media.get_element()
            if element:
                self.appsrc = element.get_by_name("source")
                if self.appsrc:
                    # ê³ í™”ì§ˆ ì„¤ì •
                    self.appsrc.set_property("is-live", True)
                    self.appsrc.set_property("block", False)
                    self.appsrc.set_property("max-buffers", 2)
                    self.appsrc.set_property("drop", True)
                    
                    caps = Gst.Caps.from_string("video/x-raw,format=BGR,width=1280,height=720,framerate=25/1")
                    self.appsrc.set_property("caps", caps)
                    print("âœ“ ê³ í™”ì§ˆ appsrc êµ¬ì„± ì™„ë£Œ")
        except Exception as e:
            print(f"ë¯¸ë””ì–´ êµ¬ì„± ì˜¤ë¥˜: {e}")
    
    def push_frame(self, frame):
        """ê³ í™”ì§ˆ í”„ë ˆì„ í‘¸ì‹œ"""
        try:
            if not self.running or self.appsrc is None:
                return False
            
            # ê³ í™”ì§ˆ í¬ê¸°ë¡œ ì¡°ì •
            if frame.shape[:2] != (720, 1280):
                frame = cv2.resize(frame, (1280, 720), interpolation=cv2.INTER_LINEAR)
            
            # ë°ì´í„° ë³€í™˜
            data = frame.tobytes()
            buf = Gst.Buffer.new_allocate(None, len(data), None)
            buf.fill(0, data)
            
            # íƒ€ì„ìŠ¤íƒ¬í”„
            self.frame_count += 1
            buf.pts = self.frame_count * (Gst.SECOND // 25)  # 25fps
            buf.duration = Gst.SECOND // 25
            
            # í‘¸ì‹œ
            retval = self.appsrc.emit('push-buffer', buf)
            return retval == Gst.FlowReturn.OK
                
        except:
            return False
    
    def stop_server(self):
        """ì„œë²„ ì¤‘ì§€"""
        if self.running:
            self.running = False
            if self.appsrc:
                try:
                    self.appsrc.emit("end-of-stream")
                except:
                    pass
            if self.mainloop:
                try:
                    self.mainloop.quit()
                except:
                    pass
    
    def get_rtsp_url(self):
        return f"rtsp://spcwtech.mooo.com:{self.port}{self.mount_point}"

class SmartRKNNDetector:
    """ìŠ¤ë§ˆíŠ¸ RKNN ë””í…í„° - í™”ì§ˆ ìš°ì„ """
    def __init__(self, model_path='/home/spcwtech/yolo5n_fish-rk3566.rknn'):
        print("ğŸ¯ ìŠ¤ë§ˆíŠ¸ RKNN ë””í…í„° ì´ˆê¸°í™”...")
        
        # RKNN ëª¨ë¸ ë¡œë“œ
        self.rknn = RKNN()
        ret = self.rknn.load_rknn(model_path)
        if ret != 0:
            raise Exception('RKNN ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨')
        
        ret = self.rknn.init_runtime()
        if ret != 0:
            raise Exception('RKNN ëŸ°íƒ€ì„ ì´ˆê¸°í™” ì‹¤íŒ¨')
        
        self.input_size = 640
        
        # ğŸ¯ ìŠ¤ë§ˆíŠ¸ ìµœì í™” ì„¤ì •
        self.adaptive_skip = True
        self.base_skip_rate = 2  # ê¸°ë³¸ 2í”„ë ˆì„ë§ˆë‹¤ ì²˜ë¦¬
        self.current_skip_rate = self.base_skip_rate
        self.frame_counter = 0
        self.last_detections = []
        self.detection_confidence = 0.0
        
        # ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
        self.processing_times = []
        self.max_processing_time = 100  # 100ms ëª©í‘œ
        
        print("âœ“ ìŠ¤ë§ˆíŠ¸ ë””í…í„° ì´ˆê¸°í™” ì™„ë£Œ")
    
    def letterbox(self, img, new_shape=(640, 640)):
        """ê³ í’ˆì§ˆ ë¦¬ì‚¬ì´ì¦ˆ"""
        return cv2.resize(img, new_shape, interpolation=cv2.INTER_LINEAR)
    
    def decode_predictions(self, output, conf_thres=0.4):
        """ì •í™•í•œ ë””ì½”ë”©"""
        predictions = []
        try:
            for detection in output[0]:
                if len(detection) >= 6:
                    confidence = float(detection[4])
                    if confidence > conf_thres:
                        x, y, w, h = detection[:4]
                        class_id = int(detection[5])
                        predictions.append([x, y, w, h, confidence, class_id])
        except:
            pass
        return predictions
    
    def adapt_skip_rate(self, processing_time):
        """ì²˜ë¦¬ ì‹œê°„ì— ë”°ë¥¸ ì ì‘í˜• ìŠ¤í‚µ ë ˆì´íŠ¸"""
        if not self.adaptive_skip:
            return
        
        self.processing_times.append(processing_time * 1000)  # msë¡œ ë³€í™˜
        if len(self.processing_times) > 10:
            self.processing_times = self.processing_times[-10:]
        
        avg_time = sum(self.processing_times) / len(self.processing_times)
        
        if avg_time > self.max_processing_time * 1.5:
            # ì²˜ë¦¬ê°€ ë„ˆë¬´ ëŠë¦¬ë©´ ìŠ¤í‚µ ë ˆì´íŠ¸ ì¦ê°€
            self.current_skip_rate = min(5, self.current_skip_rate + 1)
        elif avg_time < self.max_processing_time * 0.7:
            # ì²˜ë¦¬ê°€ ë¹ ë¥´ë©´ ìŠ¤í‚µ ë ˆì´íŠ¸ ê°ì†Œ
            self.current_skip_rate = max(1, self.current_skip_rate - 1)
    
    def detect(self, frame):
        """ìŠ¤ë§ˆíŠ¸ ê°ì§€"""
        try:
            start_time = time.time()
            
            # ğŸ¯ ì ì‘í˜• í”„ë ˆì„ ìŠ¤í‚µ
            self.frame_counter += 1
            if self.frame_counter % self.current_skip_rate != 0:
                # ì´ì „ ê²°ê³¼ ì¬ì‚¬ìš©í•˜ì§€ë§Œ í™”ì§ˆì€ ìœ ì§€
                return self.draw_cached_detections(frame)
            
            # ì „ì²˜ë¦¬
            input_frame = self.letterbox(frame, (self.input_size, self.input_size))
            input_frame = np.expand_dims(input_frame, axis=0)
            
            # RKNN ì¶”ë¡ 
            outputs = self.rknn.inference(inputs=[input_frame])
            
            # í›„ì²˜ë¦¬
            predictions = self.decode_predictions(outputs, conf_thres=0.4)
            
            # ê²°ê³¼ ìºì‹œ ë° ì‹ ë¢°ë„ ì—…ë°ì´íŠ¸
            self.last_detections = predictions
            if predictions:
                self.detection_confidence = max([p[4] for p in predictions])
            
            # ì²˜ë¦¬ ì‹œê°„ ê¸°ë°˜ ì ì‘
            processing_time = time.time() - start_time
            self.adapt_skip_rate(processing_time)
            
            # ê·¸ë¦¬ê¸°
            return self.draw_detections(frame, predictions)
            
        except Exception as e:
            print(f"ê°ì§€ ì˜¤ë¥˜: {e}")
            return frame
    
    def draw_cached_detections(self, frame):
        """ìºì‹œëœ ê°ì§€ ê²°ê³¼ ê·¸ë¦¬ê¸° - ê³ í™”ì§ˆ ìœ ì§€"""
        return self.draw_detections(frame, self.last_detections)
    
    def draw_detections(self, frame, detections):
        """ê³ í’ˆì§ˆ ê°ì§€ ê²°ê³¼ ê·¸ë¦¬ê¸°"""
        for det in detections:
            try:
                x, y, w, h, conf, class_id = det
                
                # ì›ë³¸ í•´ìƒë„ì— ë§ê²Œ ì¢Œí‘œ ì¡°ì •
                scale_x = frame.shape[1] / self.input_size
                scale_y = frame.shape[0] / self.input_size
                
                x1 = int((x - w/2) * scale_x)
                y1 = int((y - h/2) * scale_y)
                x2 = int((x + w/2) * scale_x)
                y2 = int((y + h/2) * scale_y)
                
                # ê³ í’ˆì§ˆ ê·¸ë¦¬ê¸°
                cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)
                
                # ë°°ê²½ì´ ìˆëŠ” í…ìŠ¤íŠ¸
                text = f'{conf:.2f}'
                (text_width, text_height), _ = cv2.getTextSize(text, cv2.FONT_HERSHEY_SIMPLEX, 0.6, 2)
                cv2.rectangle(frame, (x1, y1-text_height-10), (x1+text_width, y1), (0, 255, 0), -1)
                cv2.putText(frame, text, (x1, y1-5), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 0), 2)
                
            except:
                continue
        
        # ì„±ëŠ¥ ì •ë³´ í‘œì‹œ
        cv2.putText(frame, f'Skip Rate: 1/{self.current_skip_rate}', (10, 30), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 0), 2)
        if self.processing_times:
            avg_time = sum(self.processing_times[-5:]) / len(self.processing_times[-5:])
            cv2.putText(frame, f'Process: {avg_time:.1f}ms', (10, 60), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 0), 2)
        
        return frame

class FrameBuffer:
    """ìŠ¤ë§ˆíŠ¸ í”„ë ˆì„ ë²„í¼"""
    def __init__(self, maxsize=3):
        self.queue = queue.Queue(maxsize=maxsize)
        self.lock = threading.Lock()
    
    def put_frame(self, frame):
        """í”„ë ˆì„ ì¶”ê°€ (ê°€ë“ ì°¬ ê²½ìš° ì˜¤ë˜ëœ í”„ë ˆì„ ì œê±°)"""
        with self.lock:
            if self.queue.full():
                try:
                    self.queue.get_nowait()  # ì˜¤ë˜ëœ í”„ë ˆì„ ì œê±°
                except queue.Empty:
                    pass
            
            try:
                self.queue.put_nowait(frame)
                return True
            except queue.Full:
                return False
    
    def get_frame(self):
        """ìµœì‹  í”„ë ˆì„ ê°€ì ¸ì˜¤ê¸°"""
        with self.lock:
            if self.queue.empty():
                return None
            
            # íì— ìˆëŠ” ëª¨ë“  í”„ë ˆì„ì„ ë¹„ìš°ê³  ê°€ì¥ ìµœì‹  ê²ƒë§Œ ë°˜í™˜
            frame = None
            while not self.queue.empty():
                try:
                    frame = self.queue.get_nowait()
                except queue.Empty:
                    break
            
            return frame

def main():
    """ê³ í™”ì§ˆ ë©”ì¸ í•¨ìˆ˜"""
    print("ğŸ¯ ê³ í™”ì§ˆ ì‹¤ì‹œê°„ ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¬ë° ì‹œì‘")
    
    cap = None
    detector = None
    gst_server = None
    frame_buffer = FrameBuffer(maxsize=2)
    
    try:
        # GStreamer ì´ˆê¸°í™”
        if not Gst.is_initialized():
            Gst.init(None)
        
        # ì¹´ë©”ë¼ ì°¾ê¸°
        video_device = find_working_camera()
        
        # ì¹´ë©”ë¼ ì´ˆê¸°í™” (ê³ í™”ì§ˆ ì„¤ì •)
        cap = cv2.VideoCapture(video_device)
        cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)
        cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)
        cap.set(cv2.CAP_PROP_FPS, 30)
        cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)
        
        # ì¶”ê°€ í™”ì§ˆ ì„¤ì •
        cap.set(cv2.CAP_PROP_FOURCC, cv2.VideoWriter_fourcc('M', 'J', 'P', 'G'))
        cap.set(cv2.CAP_PROP_BRIGHTNESS, 0.5)
        cap.set(cv2.CAP_PROP_CONTRAST, 0.5)
        cap.set(cv2.CAP_PROP_SATURATION, 0.5)
        
        if not cap.isOpened():
            raise Exception("ì¹´ë©”ë¼ë¥¼ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
        
        print("âœ“ ê³ í™”ì§ˆ ì¹´ë©”ë¼ ì´ˆê¸°í™” ì™„ë£Œ")
        
        # ìŠ¤ë§ˆíŠ¸ ë””í…í„° ì´ˆê¸°í™”
        detector = SmartRKNNDetector()
        
        # ê³ í™”ì§ˆ RTSP ì„œë²„ ì´ˆê¸°í™”
        gst_server = HighQualityGStreamerRTSPServer(port=7201, mount_point="/hq")
        if not gst_server.start_server():
            raise Exception("RTSP ì„œë²„ ì‹œì‘ ì‹¤íŒ¨")
        
        print(f"\nğŸ¥ ê³ í™”ì§ˆ ìŠ¤íŠ¸ë¦¬ë° URL: {gst_server.get_rtsp_url()}")
        print("ğŸ¯ ê³ í™”ì§ˆ ì²˜ë¦¬ ì‹œì‘... (Ctrl+Cë¡œ ì¢…ë£Œ)")
        
        # ìº¡ì²˜ ìŠ¤ë ˆë“œ
        def capture_thread():
            while True:
                ret, frame = cap.read()
                if ret and frame is not None:
                    frame_buffer.put_frame(frame)
                time.sleep(0.01)  # 100 FPS ìº¡ì²˜
        
        capture_t = threading.Thread(target=capture_thread, daemon=True)
        capture_t.start()
        
        frame_count = 0
        start_time = time.time()
        fps_counter = 0
        
        while True:
            # ìµœì‹  í”„ë ˆì„ ê°€ì ¸ì˜¤ê¸°
            frame = frame_buffer.get_frame()
            if frame is None:
                time.sleep(0.001)
                continue
            
            # ìŠ¤ë§ˆíŠ¸ ì²˜ë¦¬
            processed_frame = detector.detect(frame)
            
            # ê³ í™”ì§ˆ ìŠ¤íŠ¸ë¦¬ë°
            gst_server.push_frame(processed_frame)
            
            # FPS ì¹´ìš´í„°
            fps_counter += 1
            if fps_counter % 25 == 0:
                elapsed = time.time() - start_time
                fps = fps_counter / elapsed
                print(f"ğŸ¯ ê³ í™”ì§ˆ FPS: {fps:.1f}, ìŠ¤í‚µ ë ˆì´íŠ¸: 1/{detector.current_skip_rate}")
                
                # ë¦¬ì…‹
                start_time = time.time()
                fps_counter = 0
            
            # ì ì‘í˜• ëŒ€ê¸°
            time.sleep(0.02)  # 50 FPS ì¶œë ¥
    
    except KeyboardInterrupt:
        print("\nì¢…ë£Œ ì‹ í˜¸ ë°›ìŒ...")
    except Exception as e:
        print(f"ì˜¤ë¥˜ ë°œìƒ: {e}")
        traceback.print_exc()
    finally:
        print("ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì¤‘...")
        
        if cap and cap.isOpened():
            cap.release()
            print("âœ“ ì¹´ë©”ë¼ í•´ì œ")
        
        if gst_server:
            gst_server.stop_server()
            print("âœ“ RTSP ì„œë²„ ì¤‘ì§€")
        
        if detector:
            try:
                detector.rknn.release()
            except:
                pass
            print("âœ“ ë””í…í„° ì •ë¦¬")
        
        print("âœ… ê³ í™”ì§ˆ í”„ë¡œê·¸ë¨ ì¢…ë£Œ ì™„ë£Œ")

if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        print(f"ë©”ì¸ í•¨ìˆ˜ ì˜¤ë¥˜: {e}")
        traceback.print_exc()
